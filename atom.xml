<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沐雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanghua-code.github.io/"/>
  <updated>2019-11-11T13:22:19.979Z</updated>
  <id>http://fanghua-code.github.io/</id>
  
  <author>
    <name>fanghua-code</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>查找算法</title>
    <link href="http://fanghua-code.github.io/2019/11/11/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>http://fanghua-code.github.io/2019/11/11/查找算法/</id>
    <published>2019-11-11T12:15:36.000Z</published>
    <updated>2019-11-11T13:22:19.979Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><h5 id="常用的查找算法"><a href="#常用的查找算法" class="headerlink" title="常用的查找算法"></a>常用的查找算法</h5><hr><p>在java中，我们常用到的算法有四种：</p><ol><li><p>顺序（线性）查找</p></li><li><p>二分（折半）查找</p></li><li><p>插值查找</p></li><li><p>斐波那契查找</p><a id="more"></a></li></ol><hr><h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><hr><p>​        顺序查找是最简单的查找方式，直接通过遍历序列来查找指定值，这种查找方式对序列不做要求，但查找效率低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线性查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线性查找数组中的值，找到返回下标，找不到返回-1</span></span><br><span class="line"><span class="comment">     * 若数组中存在多个要查找的值，则返回排在前面要查找的值的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 查找的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 需要查找的值的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试线性查找</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = SeqSearch.search(arr, <span class="number">4</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        测试：</p><p>​                <img src="/2019/11/11/查找算法/seqSearchTest.png" alt></p><hr><h5 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h5><hr><ol><li><p>二分查找也称折半查找（Binary Sort），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p></li><li><p>算法要求：</p><ul><li>必须采用顺序存储结构</li><li>必须按关键字大小有序排列</li></ul></li><li><p>应用实例：</p><ul><li><p>请对一个有序数组进行二分查找{1, 8, 10, 89, 1000, 1234}，输入一个数看数组是否存在此数，并且求出下标，如果没有就提示“没有这个数”。</p></li><li><p>思路分析：</p><ul><li>首先确定该数组的中间元素的下标：mid = (left + right) / 2</li><li>然后让需要查找的值val和arr[mid]进行比较</li><li>如果val &gt; arr[mid] ，说明要查找的值在arr[mid]的右边，于是向右边进行递归查找</li><li>如果val &lt; arr[mid] ，说明要查找的值在arr[mid]的左边，于是向左边进行递归查找</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 注：查找序列一定是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法（不考虑序列中有多个所要查找的值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 查找序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若序列中存在要查找的值，返回下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &gt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试二分查找</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = search(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, -<span class="number">11</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>​        <img src="/2019/11/11/查找算法/BinarySortTest1.png" alt></p></li></ul></li><li><p>思考：{1, 8, 10, 89, 1000, 1000, 1000, 1234}当一个有序数组中有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000</p><ul><li><p>分析：在找到所要查找的数值时，往该数值的左右进行扫描，查看是否还存在其他该数值的元素，将这些元素的下标存入List集合并返回</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> * 注：查找序列一定是有序的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找算法（考虑序列中存在多个所要查找的值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 查找序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若序列中存在要查找的值，将所有该值的下标放入List集合中并返回。否则返回空集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; resIndexList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &gt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, right, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, left, mid - <span class="number">1</span>, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resIndexList.add(mid);</span><br><span class="line">            <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//向左扫描，查看是否还存在需要查找的val</span></span><br><span class="line">            <span class="keyword">while</span> (temp &gt;= left &amp;&amp; arr[temp] == val) &#123;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp --;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//向右扫描，查看是否还存在需要查找的val</span></span><br><span class="line">            <span class="keyword">while</span> (temp &lt;= right &amp;&amp; arr[temp] == val) &#123;</span><br><span class="line">                resIndexList.add(temp);</span><br><span class="line">                temp ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resIndexList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试二分查找</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; indexs = search(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(indexs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>​        <img src="/2019/11/11/查找算法/BinarySortTest2.png" alt></p></li></ul></li></ol><hr><h5 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h5><hr><ol><li><p>原理介绍：</p><ul><li><p>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找</p></li><li><p>将折半查找中的mid索引的公式进行改进：</p><p>mid = low + (high - low) * (val - arr[low]) / (arr[high] - arr[low])</p><p><img src="/2019/11/11/查找算法/mid.png" alt></p></li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入查找算法（不考虑数组中存在多个序偶要查找的值）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 查找数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low 左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 所要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若数组中存在所要查找的值，返回下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        <span class="keyword">if</span> (low &gt; high || val &lt; arr[<span class="number">0</span>] || val &gt;arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) * (val - arr[low]) / (arr[high] - arr[low]);</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (val &gt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, mid + <span class="number">1</span>, high, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; pivot) &#123;</span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            <span class="keyword">return</span> search(arr, low, mid - <span class="number">1</span>, val);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试插入查找</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = InsertValueSearch.search1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>​        <img src="/2019/11/11/查找算法/InsertValueTest.png" alt></p></li><li><p>在数组{1, 2, 3……, 100}中查找1和38，比较二分查找和插值查找（在两个查找方法中第一行输出hello查看查找所需次数</p><p><img src="/2019/11/11/查找算法/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE1.png" alt></p><p><img src="/2019/11/11/查找算法/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE1.png" alt></p><p><img src="/2019/11/11/查找算法/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE38.png" alt></p><p><img src="/2019/11/11/查找算法/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE38.png" alt></p></li><li><p>插值查找注意事项：</p><ul><li>对于数据量较大，关键字分布比较均匀的查找序列来说，采用插值查找速度较快</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li></ul></li></ol><hr><h5 id="斐波那契（黄金分割法）查找算法"><a href="#斐波那契（黄金分割法）查找算法" class="headerlink" title="斐波那契（黄金分割法）查找算法"></a>斐波那契（黄金分割法）查找算法</h5><hr><ol><li><p>基本介绍：</p><ul><li>黄金分割点是指一条线段分割为两部分，使其中一部分与全长之比等于另一部分之比。取其前三位数字的近似值时0.618.由于按此比例设计的造型十分美丽，因此称为黄金分割，也称中外比。这是一个神奇的数字，会带来意想不到的效果</li><li>斐波那契数列{1, 1, 2, 3, 5, 8, 13, 21, 34, 55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618.</li></ul></li><li><p>斐波那契原理：</p><ul><li><p>斐波那契查找原理与前两种相似，仅仅改变了mid的位置，mid不再是中间或插值得到。而是位于黄金分割点附近，即mid = low + F(k - 1) - 1（F表示斐波那契数列）</p><p><img src="/2019/11/11/查找算法/Fibonacci.png" alt></p></li><li><p>对F(k - 1) - 1的理解</p><ul><li><p>有斐波那契数列F[k] = F[k - 1] + F[k - 2]的性质。可以得到(F[k] - 1) = (F[k - 1] - 1) + (F[k - 2] - 1) + 1。该试说明，只要顺序表的长度为F[K] - 1，则可以将该表分成长度为F[k - 1] - 1和F[k - 2] - 1的两段，即如上图所示。从而中间位置为mid = low + F(k - 1) - 1</p></li><li><p>类似的，每一子段也可以用相同的方法分割</p></li><li><p>但顺序表长度n不一定刚好等于F[k] - 1，所以需要将原来的顺序表长度n增加至F[k] - 1.这里的K值只要能使得F[k] - 1恰好大于或等于n即可，由以下代码得到顺序表长度增加后，新增的位置（从n + 1到F[k] - 1位置），都赋为n位置的值即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n &gt; fib(k) - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契查找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到一个指定大小的斐波那契数列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 斐波那契数列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 斐波那契查找方法（非递归方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 查找序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 所要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若查找序列中存在所要查找的值，返回下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//左边索引</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右边索引</span></span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//中间索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//斐波那契数列的黄金分割点</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] F = fib();</span><br><span class="line">        <span class="comment">//找到时数组长度恰好小于等于F[k] - 1的k值</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; F[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组扩充为长度F[k]的数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, F[k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (val &lt; temp[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &gt; temp[mid]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试斐波那契查找</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = search(arr, <span class="number">1</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p>​        <img src="/2019/11/11/查找算法/FibonacciTest.png" alt></p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;查找算法&quot;&gt;&lt;a href=&quot;#查找算法&quot; class=&quot;headerlink&quot; title=&quot;查找算法&quot;&gt;&lt;/a&gt;查找算法&lt;/h3&gt;&lt;h5 id=&quot;常用的查找算法&quot;&gt;&lt;a href=&quot;#常用的查找算法&quot; class=&quot;headerlink&quot; title=&quot;常用的查找算法&quot;&gt;&lt;/a&gt;常用的查找算法&lt;/h5&gt;&lt;hr&gt;
&lt;p&gt;在java中，我们常用到的算法有四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;顺序（线性）查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;二分（折半）查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插值查找&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;斐波那契查找&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://fanghua-code.github.io/2019/11/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://fanghua-code.github.io/2019/11/09/排序算法/</id>
    <published>2019-11-09T08:40:10.000Z</published>
    <updated>2019-11-09T10:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><hr><ol><li><p>排序算法的介绍：</p><ol><li><p>排序也称为排序算法（Sort Algorithm），排序时将一组数据进行排列的过程。</p></li><li><p>排序的分类：</p><p><img src="/2019/11/09/排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png" alt></p><a id="more"></a><ul><li>内部排序法（使用内存）：直降需要处理的素有数据都加载到内部存储器中进行排序</li><li>外部排序法：数据量过大，无法全部加载到内存中，需要借助外部储存进行排序</li></ul></li></ol></li><li><p>常见的时间复杂度：</p><p><img src="/2019/11/09/排序算法/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt></p></li><li><p>常见算法的比较情况：</p><p><img src="/2019/11/09/排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E6%83%85%E5%86%B51.png" alt></p></li></ol><hr><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><hr><ol><li><p>基本介绍：</p><ol><li>冒泡排序的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。</li><li><strong>因为排序的过程中，各元素不断接近自己的位置，</strong>如果一趟比较下来没有进行过交换，就说明序列有序<strong>，因此在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较</strong></li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        BubbleSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试冒泡排序的速度</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        BubbleSort.sort(testArr);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / (<span class="keyword">float</span>) <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/BubbleSortTest.png" alt></p></li></ol><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><hr><ol><li><p>基本介绍：选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一个元素，再依规定交换位置后达到排序的目的。</p></li><li><p>选择排序思想：第一次从arr[0]到arr[n - 1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n - 1]中选取最小值，与arr[1]交换……第i次从arr[i - 1]到arr[n - 1]中选取最小值，与arr[i - 1]交换……第n - 1次从arr[n - 2]到arr[n - 1]中选取最小值，与arr[n - 2]交换，总共通过n - 1次，得到一个按排序码从小到大排序的有序序列。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试选择排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">81</span>, <span class="number">64</span>, <span class="number">34</span>, <span class="number">45</span>&#125;;</span><br><span class="line">        SelectedSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试选择排序的速度</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        SelectedSort.sort(testArr);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/SelectSortTest.png" alt></p></li></ol><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><hr><ol><li><p>基本介绍：插入式排序属于内部排序法，是对欲排序的元素以插入的方式找寻该元素的适当位置，已达到排序的目的。</p></li><li><p>插入排序思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码一次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p><p><img src="/2019/11/09/排序算法/InsertSort.png" alt></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义待插入的值和待插入值的位置下标</span></span><br><span class="line">        <span class="keyword">int</span> insertVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            insertVal = arr[i];</span><br><span class="line">            insertIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通过while循环找到要插入的元素的位置</span></span><br><span class="line">            <span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];</span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当退出循环后，insertIndex + 1就是要插入元素的位置</span></span><br><span class="line">            <span class="keyword">if</span> (insertIndex + <span class="number">1</span> != i) &#123;</span><br><span class="line">                arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">17</span>, <span class="number">3</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">20</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        InsertSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试插入排序的速度</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        InsertSort.sort(testArr);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/InsertSortTest.png" alt></p></li><li><p>存在问题：<strong>当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。</strong></p><p><img src="/2019/11/09/排序算法/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E9%97%AE%E9%A2%98.png" alt></p></li></ol><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><hr><ol><li><p>基本介绍：希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，<strong>它是简单插入排序经过改进之后的一个更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</p></li><li><p>希尔排序基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好分成一组，算法变终止。</p><p><img src="/2019/11/09/排序算法/ShellSort.png" alt></p></li><li><p>注：</p><ol><li>希尔排序时，对有序序列在插入时采用交换法，排序速度相对较低，但相对好理解</li><li>希尔排序时，对有序序列在插入时采用移动法，排序速度相对较高，但相对难理解</li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序方法(交换法)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (r &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - r; j &gt;= <span class="number">0</span> ; j -= r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + r]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + r];</span><br><span class="line">                        arr[j + r] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序方法(移位法)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt;= <span class="number">1</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i ++) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                temp = arr[index];</span><br><span class="line">                <span class="keyword">while</span> (index - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[index - gap]) &#123;</span><br><span class="line">                    arr[index] = arr[index - gap];</span><br><span class="line">                    index -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (index != i) &#123;</span><br><span class="line">                    arr[index] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试希尔排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>, -<span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="comment">//ShellSort.sort1(arr);</span></span><br><span class="line">        ShellSort.sort2(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试希尔排序你的速度</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//ShellSort.sort1(testArr);</span></span><br><span class="line">        ShellSort.sort2(testArr);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/ShellSortTest.png" alt></p></li></ol><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><hr><ol><li><p>基本介绍：快速排序（Quicksort）是对冒泡排序的一种改进。</p></li><li><p>快速排序思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><img src="/2019/11/09/排序算法/QuickSort.png" alt></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//选择中间某个元素作为基准</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(high + low) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = low;</span><br><span class="line">        <span class="keyword">int</span> right = high;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//从左边往中间找比基准元素大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; pivot) &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从右边往中间找比基准元素小的元素</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; pivot) &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当left不等于right，即左边存在比基准元素大的元素或右边存在比基准元素小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="comment">//交换</span></span><br><span class="line">                temp = arr[left];</span><br><span class="line">                arr[left] = arr[right];</span><br><span class="line">                arr[right] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (arr[left] == pivot) &#123;</span><br><span class="line">                    right --;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">if</span> (arr[right] == pivot) &#123;</span><br><span class="line">                    left ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向左边递归</span></span><br><span class="line">        <span class="keyword">if</span> (right - <span class="number">1</span> &gt; low) &#123;</span><br><span class="line">            sort(arr, low, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右边递归</span></span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> &lt; high) &#123;</span><br><span class="line">            sort(arr, left + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试快速排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;-<span class="number">9</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">23</span>, -<span class="number">567</span>, <span class="number">70</span>, -<span class="number">1</span>, <span class="number">900</span>, <span class="number">4510</span>&#125;;</span><br><span class="line">        QuickSort.sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试快速排序的速度</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        QuickSort.sort(testArr, <span class="number">0</span>, testArr.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/QuickSortTest.png" alt></p></li></ol><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><hr><ol><li><p>基本介绍：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。</p></li><li><p>归并排序思想：</p><p><img src="/2019/11/09/排序算法/MergeSort1.png" alt></p><p><img src="/2019/11/09/排序算法/MergeSort2.png" alt></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拆分数组，然后合并数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组的左边第一个元素下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组的右边最后一个元素下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            sort(arr, left, mid, temp);</span><br><span class="line">            sort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并拆分后的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 原始的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 拆分后左边的开始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 拆分后左边的结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 拆分后右边的结束索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 中转数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将左右两边的数据按照从小到大填充到temp中，直到有一边填充完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//将左右两边较小的数填充到temp中</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将左右两边其中剩余一边的剩余数据依次填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t ++;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t ++;</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将temp中的数据复制到原始数组中</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t ++;</span><br><span class="line">            tempLeft ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试归并排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, -<span class="number">1</span>, <span class="number">10</span>, <span class="number">7</span>, -<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        MergeSort.sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testArr.length; i++) &#123;</span><br><span class="line">            testArr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">800000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] testTemp = <span class="keyword">new</span> <span class="keyword">int</span>[testArr.length];</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        MergeSort.sort(testArr, <span class="number">0</span>, testArr.length - <span class="number">1</span>, testTemp);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/MergeSortTest.png" alt></p></li></ol><hr><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><hr><ol><li><p>基本介绍：</p><ul><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶排序”（bucket sort 或 bin sort），顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。</li><li>基数排序时属于稳定性的排序，基数排序法是效率高的稳定性排序法。</li><li>基数排序是桶排序的扩展。</li><li>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</li></ul></li><li><p>基数排序思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序序列。</p><p><img src="/2019/11/09/排序算法/RadixSort1.png" alt></p><p><img src="/2019/11/09/排序算法/RadixSort2.png" alt></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要排序的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶，每个桶就是一个一维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">//定义一个一维数组来记录各个桶的每次存放的数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[bucket.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到数组中最大数的位数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> item : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item &gt; max) &#123;</span><br><span class="line">                max = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = (max + <span class="string">""</span>).length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLength; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">                <span class="comment">//获取数组中每一个数据的digitOfElement位数</span></span><br><span class="line">                <span class="keyword">int</span> digitOfElement = (<span class="keyword">int</span>) ((value / (Math.pow(<span class="number">10</span>, i))) % <span class="number">10</span>);</span><br><span class="line">                <span class="comment">//根据个位数将该数据放入指定的桶中</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = value;</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//按照的桶的顺序（一维数组的下标）依次取出数据，放入原来的数组</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucket.length; j++) &#123;</span><br><span class="line">                <span class="comment">//判断桶中是否有数据</span></span><br><span class="line">                <span class="keyword">if</span> (bucketElementCounts[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//桶中有数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts[j]; k++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素，放入原数组</span></span><br><span class="line">                        arr[index++] = bucket[j][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将每个桶对应的数据个数的数组置零</span></span><br><span class="line">                bucketElementCounts[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        RadixSort.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试基数排序的速度</span></span><br><span class="line">        <span class="comment">//试想，如果是80000000需要多大的内存：</span></span><br><span class="line">        <span class="comment">//80000000 * 10 * 4 / 1024/ 1024 / 1024 = 2.98 G</span></span><br><span class="line">        <span class="keyword">int</span>[] testArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">        RadixSort.sort(testArr);</span><br><span class="line">        <span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">        System.out.println((t2 - t1) / <span class="number">1000.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/09/排序算法/RadixSortTest.png" alt></p></li><li><p><strong>注：基数排序会耗费额外的内存，如果需要排序的个数过多，会抛出内存不足的异常</strong></p></li><li><p>基数排序的说明：</p><ul><li>基数排序是对桶排序的扩展，速度很快。</li><li>基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError。</li><li>基数排序是稳定的。【注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，<strong>则称这种排序算法时稳定的，否则称为不稳定的</strong>】。</li><li><strong>有负数的数组，我们不用基数排序来进行排序，如果要支持负数，参考：</strong><a href="https://code.i-harness.com/zh-CN/q/e98fa9" target="_blank" rel="noopener">https://code.i-harness.com/zh-CN/q/e98fa9</a></li></ul></li></ol><hr><h3 id="以上排序算法的对比"><a href="#以上排序算法的对比" class="headerlink" title="以上排序算法的对比"></a>以上排序算法的对比</h3><hr><p><img src="/2019/11/09/排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E6%83%85%E5%86%B52.png" alt></p><ol><li><p>在对长度为80000的数组进行排序时，以上排序算法个消耗时间为：</p><ul><li><p>冒泡排序：</p><p><img src="/2019/11/09/排序算法/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>选择排序：</p><p><img src="/2019/11/09/排序算法/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>插入排序：</p><p><img src="/2019/11/09/排序算法/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>希尔排序：</p><p><img src="/2019/11/09/排序算法/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>快速排序：</p><p><img src="/2019/11/09/排序算法/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>归并排序：</p><p><img src="/2019/11/09/排序算法/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li><li><p>基数排序：</p><p><img src="/2019/11/09/排序算法/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E8%80%97%E8%B4%B9%E6%97%B6%E9%97%B4.png" alt></p></li></ul></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序算法的介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序也称为排序算法（Sort Algorithm），排序时将一组数据进行排列的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;排序的分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/09/排序算法/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB.png&quot; alt&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归回溯</title>
    <link href="http://fanghua-code.github.io/2019/11/05/%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF/"/>
    <id>http://fanghua-code.github.io/2019/11/05/递归回溯/</id>
    <published>2019-11-05T13:25:59.000Z</published>
    <updated>2019-11-05T13:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h3><hr><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><ol><li><p>基本概念：递归就是方法自己调用自己，每次调用时都传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁</p></li><li><p>递归能用于解决什么样的问题</p></li><li><ol><li>各种数学问题：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题（google编程大赛）</li><li>各种算法中也会使用到递归，比如：快排、归并排序、二分查找、分治算法等</li><li>将用栈解决的问题 ==》递归代码比较简洁</li></ol></li><li><p>递归需要遵循的重要规则</p></li><li><ol><li>执行方法时，就创建一个新的受保护的独立空间（栈空间）</li><li>方法的局部变量时独立的不会互相影响</li><li>递归必须向退出递归的条件逼近，否则就是无限递归</li><li>当一个方法执行完毕，或者遇到return，就会返回，遵循谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕</li></ol></li></ol><a id="more"></a><h5 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h5><ul><li><ol><li><p>分析：</p></li><li><ol><li>将迷宫地图映射成一个二维数组</li><li>二维数组中用1表示迷宫的墙、2表示出迷宫的通路，3表示走过的路，但走不通，0表示还未走过的路</li><li>自定义一个寻找通路的策略，如：下 ==》右 ==》上 ==》左</li></ol></li><li><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迷宫回溯问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组，模拟迷宫</span></span><br><span class="line">        <span class="comment">//地图</span></span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//用1表示墙</span></span><br><span class="line">        <span class="comment">//上下全置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右全置为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置额外的墙</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : row) &#123;</span><br><span class="line">                System.out.print(item + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用递归函数给小球找路</span></span><br><span class="line">        <span class="comment">//setWay(map, 1, 1);</span></span><br><span class="line">        setWay2(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出路线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> item : row) &#123;</span><br><span class="line">                System.out.print(item + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">     * 说明：</span></span><br><span class="line"><span class="comment">     * 1、map表示迷宫地图</span></span><br><span class="line"><span class="comment">     * 2、i、j表示从地图的哪一个位置开始出发（1,1），小球到达map[6][5]的位置</span></span><br><span class="line"><span class="comment">     * 3、约定：当map[i][j]为0时表示该点没有走过，为1表示墙，2表示通路可以走，3表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">     * 4、在走迷宫时，需要确定一个策略（方法）：下 ==》右 ==》上 ==》左，如果走不通，再回溯</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 出发的位置横坐标，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 出发的位置纵坐标，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到出迷宫的通路，则返回true，反之则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay1</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断通路是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//通路已找到，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通路未找到，按照策略来寻找通路：下 ==》右 ==》上 ==》左</span></span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这个位置还没走过</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (setWay1(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的下方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay1(map, i , j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的右方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay1(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的上方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay1(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的左方走，并找到通路返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//表示该点走不通，将该位置置为3，表示走不通</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//该位置不为0时，可能为1、2、3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改找路的策略：上 ==》右 ==》下 ==》左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 出发的位置横坐标，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 出发的位置纵坐标，从0开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到出迷宫的通路，则返回true，反之则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断通路是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//通路已找到，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通路未找到，按照策略来寻找通路：下 ==》右 ==》上 ==》左</span></span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//这个位置还没走过</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (setWay2(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的上方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i , j + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的右方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的下方走，找到通路并返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//表示往该位置的左方走，并找到通路返回true</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//表示该点走不通，将该位置置为3，表示走不通</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//该位置不为0时，可能为1、2、3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="/2019/11/05/递归回溯/MiGong.png" alt></p></li></ol></li></ul><h5 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h5><ul><li><ol><li><p>问题介绍：在8X8格子的国际象棋上摆放八个皇后，使其不能互相攻击。即：<strong>任意两个皇后都不能处于同一行、同一列或同一斜线上、问有多少种摆法。</strong></p><p><img src="/2019/11/05/递归回溯/xQueen.png" alt></p></li><li><p>思路分析：</p><ol><li>第一个皇后先放在第一行第一列</li><li>第二个皇后放在第二行第一列，然后判断该位置是否可以摆放，如果不可以摆放，继续放在第二列、第三列。。。依次把所有列都放完，找到一个合适</li><li>继续第三个皇后，还是第一列、第二列。。。知道第八个皇后也能放在一个不冲突的位置，算是找到了一个正解</li><li>当得到第一个正解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放到第一列的所有正解，全部得到</li><li>然后回头继续第一个皇后放在第二列，后面继续循环执行1、2、3、4的步骤</li><li><strong>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。arr[8] = {0, 4, 7, 5, 2, 6, 1, 3}arr下标表示第几行，即第几个皇后，arr[i]表示第i+1个皇后放在第i+1行的地arr[i] + 1列</strong></li></ol></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xQueen</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个变量表示八个皇后</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//定义一个一维数组，保存八皇后放置位置的结果，如：arr = &#123;0, 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="comment">//八皇后的解法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将皇后的摆放情况输出，即将一位数组输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当我们放置第n个皇后时该皇后是否与之前放置的皇后相冲突</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当第n个皇后与之前反置的皇后相冲突时，返回false，不冲突时返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * arr[i] == arr[n - 1] 判断第n个皇后是否和之前摆放的皇后在同一列</span></span><br><span class="line"><span class="comment">             * Math.abs(n - 1 - i) == Math.abs(arr[n - 1] - arr[i] 判断第n个皇后是否和之前摆放的皇后在同一斜线</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[n - <span class="number">1</span>] || Math.abs(n - <span class="number">1</span> - i) == Math.abs(arr[n - <span class="number">1</span>] - arr[i])) &#123;</span><br><span class="line">                <span class="comment">//第n个皇后和之前摆放的皇后在同一列或者在同一斜线，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 放置第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 第n个皇后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断八个皇后是否全部放置完成</span></span><br><span class="line">        <span class="keyword">if</span> (n - <span class="number">1</span> == max) &#123;</span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            arr[n - <span class="number">1</span>] = i;</span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123;</span><br><span class="line">                <span class="comment">//放置皇后位置不冲突，摆放下一个皇后</span></span><br><span class="line">                place(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试八皇后问题</span></span><br><span class="line">        xQueen queen = <span class="keyword">new</span> xQueen();</span><br><span class="line">        queen.place(<span class="number">1</span>);</span><br><span class="line">        System.out.printf(<span class="string">"一共有%d种解法"</span>, xQueen.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="/2019/11/05/递归回溯/showXQueen.png" alt></p></li></ol></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;递归回溯&quot;&gt;&lt;a href=&quot;#递归回溯&quot; class=&quot;headerlink&quot; title=&quot;递归回溯&quot;&gt;&lt;/a&gt;递归回溯&lt;/h3&gt;&lt;hr&gt;&lt;h5 id=&quot;递归&quot;&gt;&lt;a href=&quot;#递归&quot; class=&quot;headerlink&quot; title=&quot;递归&quot;&gt;&lt;/a&gt;递归&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;基本概念：递归就是方法自己调用自己，每次调用时都传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;递归能用于解决什么样的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;各种数学问题：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题（google编程大赛）&lt;/li&gt;
&lt;li&gt;各种算法中也会使用到递归，比如：快排、归并排序、二分查找、分治算法等&lt;/li&gt;
&lt;li&gt;将用栈解决的问题 ==》递归代码比较简洁&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;递归需要遵循的重要规则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;执行方法时，就创建一个新的受保护的独立空间（栈空间）&lt;/li&gt;
&lt;li&gt;方法的局部变量时独立的不会互相影响&lt;/li&gt;
&lt;li&gt;递归必须向退出递归的条件逼近，否则就是无限递归&lt;/li&gt;
&lt;li&gt;当一个方法执行完毕，或者遇到return，就会返回，遵循谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组和队列</title>
    <link href="http://fanghua-code.github.io/2019/11/03/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://fanghua-code.github.io/2019/11/03/稀疏数组和队列/</id>
    <published>2019-11-03T08:16:50.000Z</published>
    <updated>2019-11-03T08:53:00.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h5><hr><ol><li><p>稀疏数组：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组 </p></li><li><p>处理方法：</p><ol><li><p>记录数组一共几行几列，有多少个不为0的元素</p></li><li><p>把 不为0的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p><p><img src="/2019/11/03/稀疏数组和队列/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84.png" alt></p></li></ol><a id="more"></a></li><li><p>应用实例：</p><ol><li><p>使用稀疏数组来保留非0元素较多的二维数组（棋盘、地图等等）</p></li><li><p>把稀疏数组存盘，并且可以重新恢复为原来的二维数组</p></li><li><p>分析：</p><ul><li><p>二维数组 ==》稀疏数组</p><ul><li>遍历原始的二维数组，得到有效数据（非0元素）的个数sum</li><li>根据sum就可以创建稀疏数组sparseArr int[sum+1][3]</li><li>将二维数组的有效数据存入到稀疏数组</li></ul></li><li><p>稀疏数组 ==》二维数组</p><ul><li><p>先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</p></li><li><p>再读取稀疏数组后几行的数据，并赋给原始二维数组即可</p><p><img src="/2019/11/03/稀疏数组和队列/%E5%88%86%E6%9E%90%E5%9B%BE.png" alt></p></li></ul></li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维数组与稀疏数组的转换（这里以棋盘的存档与读档为例）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArrDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//0、先创建原始的11x11的二维数组，0表示没有棋子，1表示黑子，2表示白子</span></span><br><span class="line">        <span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;  <span class="comment">//棋盘第二行第三列有一颗黑子</span></span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;  <span class="comment">//棋盘第三行第四列有一颗白子</span></span><br><span class="line">        <span class="comment">//遍历原始数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、二维数组 ==》稀疏数组</span></span><br><span class="line">        <span class="comment">//遍历原始二维数组，获取非0元素个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//给稀疏数组第一行赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//用于记录第几个非0数据</span></span><br><span class="line">        <span class="comment">//遍历原始数组，将非0元素添加到稀疏数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出稀疏数组的形式</span></span><br><span class="line">        System.out.println(<span class="string">"得到的稀疏数组的形式："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、稀疏数组 ==》文件</span></span><br><span class="line">        OutputStream out = <span class="keyword">null</span>;</span><br><span class="line">        PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            out = <span class="keyword">new</span> FileOutputStream(<span class="string">"map.txt"</span>);</span><br><span class="line">            ps = <span class="keyword">new</span> PrintStream(out);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                    ps.print(sparseArr[i][j] + <span class="string">","</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ps.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、文件 ==》稀疏数组</span></span><br><span class="line">        String arr1[] = <span class="keyword">new</span> String[sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> arr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"map.txt"</span>));</span><br><span class="line">            String line = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                arr1[i] = line;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sum + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                String[] split = arr1[j].split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; split.length; k++) &#123;</span><br><span class="line">                    arr2[j][k] = Integer.parseInt(split[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : arr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、稀疏数组 ==》二维数组</span></span><br><span class="line">        <span class="comment">//先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">        <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[arr2[<span class="number">0</span>][<span class="number">0</span>]][arr2[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">        <span class="comment">//载读取稀疏数组的后几行的数据（从第二行开始），并赋给原始的二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">            chessArr2[arr2[i][<span class="number">0</span>]][arr2[i][<span class="number">1</span>]] = arr2[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"还原的原始二维数组："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">                System.out.print(data + <span class="string">"\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><p><img src="/2019/11/03/稀疏数组和队列/%E6%B5%8B%E8%AF%951.png" alt></p></li></ol></li><li><p>队列</p><ol><li><p>队列介绍：</p><ol><li><p>队列是一个有序列表，可以用数组或是链表来实现</p></li><li><p>遵循先入先出的原则。即：先存入队列的数据先取出，后存入队列的数据后取出</p></li><li><p>示意图：</p><p><img src="/2019/11/03/稀疏数组和队列/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt></p></li></ol></li><li><p>数组模拟队列</p><ol><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图。其中maxSize是该队列的最大容量</p></li><li><p>因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据的输出而改变，而rear则是随着数据的输入而改变</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;  <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s(show)：展示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit)：退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add)：添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get)：从队列取出元素"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head)：查看队列头数据"</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.listQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入要存入的数据："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">"取出的数据是："</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> headData = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">"队列的头数据为："</span> + headData);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用数组模拟队列：编写一个ArrayQueue类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;  <span class="comment">//表示队列的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;  <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;  <span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;  <span class="comment">//用于模拟队列的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>;  <span class="comment">//指向队列头部，分析出front是指向队列头的前一个位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;  <span class="comment">//指向队列尾部，指向队列尾的数据（即队列最后一个数据）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++;  <span class="comment">//让rear后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列数据，即出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常来处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空！无数据可取"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++;  <span class="comment">//front后移</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front + <span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\t\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列头数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存在问题及优化：</p><ol><li>数组模拟的队列只能使用一次，没有达到复用的效果</li><li>使用算法，改进成一个环形队列（采用取模的方式：%）</li></ol></li><li><p>环形队列的思路分析：</p><ol><li><p>front的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，初始值为0</p></li><li><p>rear的含义做一个调整：rear指向队列最后一个元素的后一个位置，初始值为0</p></li><li><p>当队列为空时：(rear + 1) % maxSize == front</p></li><li><p>队列中有效数据的个数：(rear + maxSize - front) % maxSzie</p><p><img src="/2019/11/03/稀疏数组和队列/%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E6%80%9D%E8%B7%AF.png" alt></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试环形队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化队列</span></span><br><span class="line">        CircleArrayQueue queue = <span class="keyword">new</span> CircleArrayQueue(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">' '</span>;  <span class="comment">//接收用户输入</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s(show)：展示队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"e(exit)：退出程序"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a(add)：添加数据到队列"</span>);</span><br><span class="line">            System.out.println(<span class="string">"g(get)：从队列取出元素"</span>);</span><br><span class="line">            System.out.println(<span class="string">"h(head)：查看队列头数据"</span>);</span><br><span class="line">            key = sc.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                    queue.listQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">                    System.out.println(<span class="string">"请输入要存入的数据："</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = sc.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'g'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">"取出的数据是："</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'h'</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> headData = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">"队列的头数据为："</span> + headData);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"程序退出"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形数组队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;  <span class="comment">//表示队列的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;  <span class="comment">//队列头，指向队列头部，指向队列第一个元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;  <span class="comment">//队列尾，指向队列尾部，指向队列最后一个元素的后一个位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;  <span class="comment">//用于模拟队列的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> front == rear;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接添加元素</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//将rear后移，这里要考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列数据，即出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//通过抛出异常来处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空！无数据可取"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把front指向的数据保存到一个临时变量</span></span><br><span class="line">        <span class="keyword">int</span> tempValue = arr[front];</span><br><span class="line">        <span class="comment">//将front后移，这里要考虑取模</span></span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> tempValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//展示队列的所有数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列为空！"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.println(arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到当前队列的大小（有效数据的个数）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列头数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列为空！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;稀疏数组和队列&quot;&gt;&lt;a href=&quot;#稀疏数组和队列&quot; class=&quot;headerlink&quot; title=&quot;稀疏数组和队列&quot;&gt;&lt;/a&gt;稀疏数组和队列&lt;/h5&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;稀疏数组：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;记录数组一共几行几列，有多少个不为0的元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 不为0的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/稀疏数组和队列/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84.png&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>逆波兰计算器</title>
    <link href="http://fanghua-code.github.io/2019/11/03/%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://fanghua-code.github.io/2019/11/03/逆波兰计算器/</id>
    <published>2019-11-03T07:35:28.000Z</published>
    <updated>2019-11-03T08:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逆波兰计算器的实现"><a href="#逆波兰计算器的实现" class="headerlink" title="逆波兰计算器的实现"></a>逆波兰计算器的实现</h3><hr><h5 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h5><ol><li><p>中缀表达式：</p><ol><li>中缀表达式就是我们最常见的表达式，如：(3+4)x5-6</li><li>中缀表达式的求值时我们最熟悉的，但是对于计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其他表达式来操作（一般转为后缀表达式）</li></ol></li><li><p>后缀表达式（逆波兰表达式）</p><ol><li><p>后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后</p><p>eg：(3+4)x5-6 ==》34+5x6- </p></li><li><p>后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果</p><p><img src="/2019/11/03/逆波兰计算器/suffix.png" alt></p></li></ol><a id="more"></a></li><li><p>中缀表达式转后缀表达式</p><ol><li><p>步骤：</p><ul><li>初始化两个栈：运算符栈s1和存储中间结果的栈s2</li><li>从左至右扫描中缀表达式</li><li>遇到操作数时，将其压入s2</li><li>遇到运算符时，比较其与s1栈顶运算符的优先级：<ol><li>如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈s1</li><li>否则，若当前运算符优先级比栈顶运算符优先级高，也将运算符压入s1</li><li>否则，将s1栈顶的运算符弹出并压入s2中，再次转到上述第1点与s1中新的栈顶运算符相比较</li></ol></li><li>遇到括号时：<ol><li>如果是左括号“（”，则直接压入s1</li><li>如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这对括号丢弃</li></ol></li><li>重复步骤2至5，直到表达式的最右端</li><li>将s1中剩余的运算符依次弹出并压入s2</li><li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li></ul></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将中缀表达式字符串转为List集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expression 中缀表达式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 中缀表达式对应的List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixList</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    String str = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ch = expression.charAt(index);</span><br><span class="line">        <span class="comment">//判断ch是否为数字</span></span><br><span class="line">        String s = Character.toString(ch);</span><br><span class="line">        <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">            <span class="comment">//ch为数字</span></span><br><span class="line">            <span class="keyword">while</span> (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = expression.charAt(index)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                s = Character.toString(ch);</span><br><span class="line">                str += s;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            ls.add(str);</span><br><span class="line">            str = <span class="string">""</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//ch为非数字，即为运算符或括号</span></span><br><span class="line">            ls.add(s);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (index &lt; expression.length());</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将中缀表达式对应的List集合转为后缀表达式的List集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 中缀表达式对应的List集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 后缀表达式对应的List集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixToSuffix</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个字符栈</span></span><br><span class="line">    Stack&lt;String&gt; operStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">    <span class="comment">//创建一个List</span></span><br><span class="line">    List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="comment">//判断s是否为数字</span></span><br><span class="line">        <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">            <span class="comment">//s为数字，直接加入到ls中</span></span><br><span class="line">            ls.add(s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"("</span>.equals(s))&#123;</span><br><span class="line">            <span class="comment">//s为左括号，直接入栈</span></span><br><span class="line">            operStack.push(s);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">")"</span>.equals(s)) &#123;</span><br><span class="line">            <span class="comment">//s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除</span></span><br><span class="line">            <span class="keyword">while</span> (!<span class="string">"("</span>.equals(operStack.peek())) &#123;</span><br><span class="line">                ls.add(operStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消除括号</span></span><br><span class="line">            operStack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//s为运算符</span></span><br><span class="line">            <span class="comment">//如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级</span></span><br><span class="line">            <span class="keyword">while</span> (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123;</span><br><span class="line">                ls.add(operStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            operStack.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!operStack.empty()) &#123;</span><br><span class="line">        ls.add(operStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 得到运算符的优先级</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oper 运算符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 优先级大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"*"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h5 id="逆波兰表达式的计算"><a href="#逆波兰表达式的计算" class="headerlink" title="逆波兰表达式的计算"></a>逆波兰表达式的计算</h5><ol><li><p>思路分析：后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算逆波兰表达式的结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 逆波兰表达式对应的List集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 逆波兰表达式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个栈</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        <span class="comment">//使用正则表达式判断s是否为数字</span></span><br><span class="line">        <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">            <span class="comment">//s为数字，直接入栈</span></span><br><span class="line">            stack.push(Integer.parseInt(s));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不是数字，为运算符</span></span><br><span class="line">            <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断运算符</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"+"</span>.equals(s)) &#123;</span><br><span class="line">                res = num2 + num1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-"</span>.equals(s)) &#123;</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(s)) &#123;</span><br><span class="line">                res = num2 * num1;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/"</span>.equals(s)) &#123;</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将res入栈</span></span><br><span class="line">            stack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后栈中的数据就是运算的结果</span></span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="完整代码实现："><a href="#完整代码实现：" class="headerlink" title="完整代码实现："></a>完整代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用栈完成逆波兰表达式的计算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 沐雨</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String infixExpression = <span class="string">"10+((2+3)*4)-5"</span>;</span><br><span class="line">        List&lt;String&gt; infixList = toInfixList(infixExpression);</span><br><span class="line">        <span class="comment">//System.out.println(infixList);</span></span><br><span class="line">        List&lt;String&gt; suffixList = infixToSuffix(infixList);</span><br><span class="line">        <span class="comment">//System.out.println(suffixList);</span></span><br><span class="line">        <span class="keyword">int</span> result = calculate(suffixList);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将中缀表达式字符串转为List集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expression 中缀表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 中缀表达式对应的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixList</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ch = expression.charAt(index);</span><br><span class="line">            <span class="comment">//判断ch是否为数字</span></span><br><span class="line">            String s = Character.toString(ch);</span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">                <span class="comment">//ch为数字</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= <span class="number">48</span> &amp;&amp; (ch = expression.charAt(index)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                    s = Character.toString(ch);</span><br><span class="line">                    str += s;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">                str = <span class="string">""</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//ch为非数字，即为运算符或括号</span></span><br><span class="line">                ls.add(s);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (index &lt; expression.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将中缀表达式对应的List集合转为后缀表达式的List集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 中缀表达式对应的List集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后缀表达式对应的List集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">infixToSuffix</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个字符栈</span></span><br><span class="line">        Stack&lt;String&gt; operStack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">        <span class="comment">//创建一个List</span></span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="comment">//判断s是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">                <span class="comment">//s为数字，直接加入到ls中</span></span><br><span class="line">                ls.add(s);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"("</span>.equals(s))&#123;</span><br><span class="line">                <span class="comment">//s为左括号，直接入栈</span></span><br><span class="line">                operStack.push(s);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">")"</span>.equals(s)) &#123;</span><br><span class="line">                <span class="comment">//s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除</span></span><br><span class="line">                <span class="keyword">while</span> (!<span class="string">"("</span>.equals(operStack.peek())) &#123;</span><br><span class="line">                    ls.add(operStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//消除括号</span></span><br><span class="line">                operStack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//s为运算符</span></span><br><span class="line">                <span class="comment">//如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级</span></span><br><span class="line">                <span class="keyword">while</span> (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123;</span><br><span class="line">                    ls.add(operStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operStack.push(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!operStack.empty()) &#123;</span><br><span class="line">            ls.add(operStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到运算符的优先级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oper 运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 优先级大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(String oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"*"</span>.equals(oper) || <span class="string">"/"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"+"</span>.equals(oper) || <span class="string">"-"</span>.equals(oper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算逆波兰表达式的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list 逆波兰表达式对应的List集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 逆波兰表达式的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="comment">//使用正则表达式判断s是否为数字</span></span><br><span class="line">            <span class="keyword">if</span> (s.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">                <span class="comment">//s为数字，直接入栈</span></span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不是数字，为运算符</span></span><br><span class="line">                <span class="keyword">int</span> num1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> num2 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//判断运算符</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"+"</span>.equals(s)) &#123;</span><br><span class="line">                    res = num2 + num1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"-"</span>.equals(s)) &#123;</span><br><span class="line">                    res = num2 - num1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"*"</span>.equals(s)) &#123;</span><br><span class="line">                    res = num2 * num1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"/"</span>.equals(s)) &#123;</span><br><span class="line">                    res = num2 / num1;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将res入栈</span></span><br><span class="line">                stack.push(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后栈中的数据就是运算的结果</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="代码测试："><a href="#代码测试：" class="headerlink" title="代码测试："></a>代码测试：</h3><p>计算10+((2+3)*4)-5</p><p>结果：</p><p><img src="/2019/11/03/逆波兰计算器/calRes.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;逆波兰计算器的实现&quot;&gt;&lt;a href=&quot;#逆波兰计算器的实现&quot; class=&quot;headerlink&quot; title=&quot;逆波兰计算器的实现&quot;&gt;&lt;/a&gt;逆波兰计算器的实现&lt;/h3&gt;&lt;hr&gt;
&lt;h5 id=&quot;中缀表达式转后缀表达式&quot;&gt;&lt;a href=&quot;#中缀表达式转后缀表达式&quot; class=&quot;headerlink&quot; title=&quot;中缀表达式转后缀表达式&quot;&gt;&lt;/a&gt;中缀表达式转后缀表达式&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;中缀表达式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中缀表达式就是我们最常见的表达式，如：(3+4)x5-6&lt;/li&gt;
&lt;li&gt;中缀表达式的求值时我们最熟悉的，但是对于计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其他表达式来操作（一般转为后缀表达式）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后缀表达式（逆波兰表达式）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后&lt;/p&gt;
&lt;p&gt;eg：(3+4)x5-6 ==》34+5x6- &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/11/03/逆波兰计算器/suffix.png&quot; alt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java数据结构与算法" scheme="http://fanghua-code.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前端zTree插件</title>
    <link href="http://fanghua-code.github.io/2019/09/27/%E5%89%8D%E7%AB%AFzTree%E6%8F%92%E4%BB%B6/"/>
    <id>http://fanghua-code.github.io/2019/09/27/前端zTree插件/</id>
    <published>2019-09-27T10:31:40.000Z</published>
    <updated>2019-11-09T10:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前端zTree插件生成树形菜单"><a href="#前端zTree插件生成树形菜单" class="headerlink" title="前端zTree插件生成树形菜单"></a>前端zTree插件生成树形菜单</h4><hr><p><img src="/2019/09/27/前端zTree插件/tree.png" alt></p><p>这种树形结构菜单大家应该不会默认吧，我们在很多地方都能看到这种结构。那么如何实现这种树形结构菜单呢？今天我来教大家使用zTree来生成简单的树形结构菜单。</p><a id="more"></a><h5 id="zTree树形结构菜单的实现"><a href="#zTree树形结构菜单的实现" class="headerlink" title="zTree树形结构菜单的实现"></a>zTree树形结构菜单的实现</h5><hr><ol><li><p>前往<a href="http://www.treejs.cn/v3/main.php#_zTreeInfo下载zTree插件。" target="_blank" rel="noopener">http://www.treejs.cn/v3/main.php#_zTreeInfo下载zTree插件。</a></p><p><img src="/2019/09/27/前端zTree插件/zTreeDown.png" alt></p><p>点击下载，前往码云下载zTree插件（未注册码云的需要注册登录才能下载）</p><p><img src="/2019/09/27/前端zTree插件/down.png" alt></p></li><li><p>下载完成后将其解压。相关文件内容如下</p><p><img src="/2019/09/27/前端zTree插件/zTree_file.png" alt></p></li><li><p>创建一个Java工程，将zTree所需要的css和js文件复制到web目录下。</p><p><img src="/2019/09/27/前端zTree插件/project.png" alt></p></li><li><p>创建HTML页面，引入相关css和js。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./zTree/css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.core.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.excheck.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>引入js文件时根据自己所需要的树形结构进行引入，可到zTree文件夹下的demo中查看，寻找自己想要的树形结构。我这里选择的是带复选框的树形结构。</p></li><li><p>设置树形菜单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var setting = &#123;</span><br><span class="line">check: &#123;</span><br><span class="line">enable: true</span><br><span class="line">&#125;,</span><br><span class="line">data: &#123;</span><br><span class="line">simpleData: &#123;</span><br><span class="line">enable: true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>采用json数据格式来设置树形菜单。</p></li><li><p>给树形菜单提供数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var zNodes =[</span><br><span class="line">    &#123; id:1, pId:0, name:&quot;随意勾选 1&quot;, open:true&#125;,</span><br><span class="line">    &#123; id:11, pId:1, name:&quot;随意勾选 1-1&quot;, open:true&#125;,</span><br><span class="line">    &#123; id:111, pId:11, name:&quot;随意勾选 1-1-1&quot;&#125;,</span><br><span class="line">    &#123; id:112, pId:11, name:&quot;随意勾选 1-1-2&quot;&#125;,</span><br><span class="line">    &#123; id:12, pId:1, name:&quot;随意勾选 1-2&quot;, open:true&#125;,</span><br><span class="line">    &#123; id:121, pId:12, name:&quot;随意勾选 1-2-1&quot;&#125;,</span><br><span class="line">    &#123; id:122, pId:12, name:&quot;随意勾选 1-2-2&quot;&#125;,</span><br><span class="line">    &#123; id:2, pId:0, name:&quot;随意勾选 2&quot;, checked:true, open:true&#125;,</span><br><span class="line">    &#123; id:21, pId:2, name:&quot;随意勾选 2-1&quot;&#125;,</span><br><span class="line">    &#123; id:22, pId:2, name:&quot;随意勾选 2-2&quot;, open:true&#125;,</span><br><span class="line">    &#123; id:221, pId:22, name:&quot;随意勾选 2-2-1&quot;, checked:true&#125;,</span><br><span class="line">    &#123; id:222, pId:22, name:&quot;随意勾选 2-2-2&quot;&#125;,</span><br><span class="line">    &#123; id:23, pId:2, name:&quot;随意勾选 2-3&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>生成属性结构菜单。</p><ol><li><p>定义生成树的容器。为固定的HTML代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 容器，将树生成在这个容器上，固定代码 --&gt;</span><br><span class="line">&lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt;</span><br></pre></td></tr></table></figure></li><li><p>生成树。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//生成树，固定的代码</span><br><span class="line">$(document).ready(function()&#123;</span><br><span class="line">    /**init方法的参数：</span><br><span class="line">     * 1、容器</span><br><span class="line">     * 2、设置</span><br><span class="line">     * 3、节点数据</span><br><span class="line">     */</span><br><span class="line">    zTreeObj = $.fn.zTree.init($(&quot;#tree&quot;), setting, zNodes);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol></li></ol><h6 id="这样，我们的树形结构菜单就生成了。"><a href="#这样，我们的树形结构菜单就生成了。" class="headerlink" title="这样，我们的树形结构菜单就生成了。"></a>这样，我们的树形结构菜单就生成了。</h6><p><img src="/2019/09/27/前端zTree插件/tree.png" alt></p><hr><h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><hr><ol><li>注意jquery的js文件引入时应在第一个<script>标签。</li><li>使用IDEA这种开发工具访问页面时要开启tomcat来访问。</li></ol><hr></script></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前端zTree插件生成树形菜单&quot;&gt;&lt;a href=&quot;#前端zTree插件生成树形菜单&quot; class=&quot;headerlink&quot; title=&quot;前端zTree插件生成树形菜单&quot;&gt;&lt;/a&gt;前端zTree插件生成树形菜单&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;/2019/09/27/前端zTree插件/tree.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;这种树形结构菜单大家应该不会默认吧，我们在很多地方都能看到这种结构。那么如何实现这种树形结构菜单呢？今天我来教大家使用zTree来生成简单的树形结构菜单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://fanghua-code.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="zTree" scheme="http://fanghua-code.github.io/tags/zTree/"/>
    
  </entry>
  
  <entry>
    <title>jquery validate插件的使用</title>
    <link href="http://fanghua-code.github.io/2019/09/26/jquery-validate%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://fanghua-code.github.io/2019/09/26/jquery-validate插件的使用/</id>
    <published>2019-09-26T00:20:52.000Z</published>
    <updated>2019-11-09T10:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="jQuery-Validate插件"><a href="#jQuery-Validate插件" class="headerlink" title="jQuery Validate插件"></a>jQuery Validate插件</h5><hr><p>做JavaWeb项目时的登录注册页面等，少不了的就是我们的表单数据的验证。而传统我们可以使用ajax、JSR 303等方法来验证表单数据，而这些都是由后台人员来编写的。今天，我来给大家介绍一个前端人员也可以做出表单数据验证方法，那就是我们的JQuery Validate插件，它提供了强大的验证功能，操作也相对简单。</p><a id="more"></a><hr><h5 id="导入js库"><a href="#导入js库" class="headerlink" title="导入js库"></a>导入js库</h5><hr><p>可以选择前往<a href="https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1下载插件" target="_blank" rel="noopener">https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1下载插件</a></p><p><img src="/2019/09/26/jquery-validate插件的使用/jq_validate.png" alt></p><p>也可以选择直接导入在线CDN：</p><p><a href="https://cdn.jsdelivr.net/npm/jquery-validation@1.19.1/dist/jquery.validate.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/npm/jquery-validation@1.19.1/dist/jquery.validate.min.js</a></p><hr><h5 id="默认校验规则"><a href="#默认校验规则" class="headerlink" title="默认校验规则"></a>默认校验规则</h5><hr><p><img src="/2019/09/26/jquery-validate插件的使用/default.png" alt></p><hr><h5 id="默认提示"><a href="#默认提示" class="headerlink" title="默认提示"></a>默认提示</h5><hr><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">messages: &#123;</span><br><span class="line">    required: "This field is required.",</span><br><span class="line">    remote: "Please fix this field.",</span><br><span class="line">    email: "Please enter a valid email address.",</span><br><span class="line">    url: "Please enter a valid URL.",</span><br><span class="line">    date: "Please enter a valid date.",</span><br><span class="line">    dateISO: "Please enter a valid date ( ISO ).",</span><br><span class="line">    number: "Please enter a valid number.",</span><br><span class="line">    digits: "Please enter only digits.",</span><br><span class="line">    creditcard: "Please enter a valid credit card number.",</span><br><span class="line">    equalTo: "Please enter the same value again.",</span><br><span class="line">    maxlength: $.validator.format( "Please enter no more than &#123;0&#125; characters." ），</span><br><span class="line">    minlength: $.validator.format( "Please enter at least &#123;0&#125; characters." ),</span><br><span class="line">    rangelength: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125; characters long." ),</span><br><span class="line">    range: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125;." ),</span><br><span class="line">    max: $.validator.format( "Please enter a value less than or equal to &#123;0&#125;." ),</span><br><span class="line">    min: $.validator.format( "Please enter a value greater than or equal to &#123;0&#125;." )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery Validate提供了中文信息提示包，位于下载包的 dist/localization/messages_zh.js，可选择将其引入到页面中，也可以选择在线CDN，这里就不再描述了</p><hr><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><hr><ol><li><p>将校验规则写到控件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $().ready(function() &#123;</span><br><span class="line">            $(&quot;#commentForm&quot;).validate();</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form class=&quot;cmxform&quot; id=&quot;commentForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;输入您的信息&lt;/legend&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label for=&quot;cname&quot;&gt;Name (必需, 最小两个字母)&lt;/label&gt;</span><br><span class="line">            &lt;input id=&quot;cname&quot; name=&quot;username&quot; minlength=&quot;2&quot; type=&quot;text&quot; required&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label for=&quot;cemail&quot;&gt;E-Mail (必需)&lt;/label&gt;</span><br><span class="line">            &lt;input id=&quot;cemail&quot; type=&quot;email&quot; name=&quot;email&quot; required&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;label for=&quot;ccomment&quot;&gt;电话 (必需)&lt;/label&gt;</span><br><span class="line">            &lt;input type=&quot;text&quot; id=&quot;ccomment&quot; name=&quot;phone&quot; required&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/09/26/jquery-validate插件的使用/check.png" alt></p><p>在键盘按下并释放及提交后验证提交表单，同时当表单失去焦点时也会进行验证</p></li><li><p>将校验规则写到js代码中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$.validator.setDefaults(&#123;</span><br><span class="line">    submitHandler: function() &#123;</span><br><span class="line">      alert(&quot;提交事件!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$().ready(function() &#123;</span><br><span class="line">// 在键盘按下并释放及提交后验证提交表单</span><br><span class="line">  $(&quot;#signupForm&quot;).validate(&#123;</span><br><span class="line">    rules: &#123;</span><br><span class="line">      firstname: &quot;required&quot;,</span><br><span class="line">      lastname: &quot;required&quot;,</span><br><span class="line">      username: &#123;</span><br><span class="line">        required: true,</span><br><span class="line">        minlength: 2</span><br><span class="line">      &#125;,</span><br><span class="line">      password: &#123;</span><br><span class="line">        required: true,</span><br><span class="line">        minlength: 5</span><br><span class="line">      &#125;,</span><br><span class="line">      confirm_password: &#123;</span><br><span class="line">        required: true,</span><br><span class="line">        minlength: 5,</span><br><span class="line">        equalTo: &quot;#password&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      email: &#123;</span><br><span class="line">        required: true,</span><br><span class="line">        email: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    messages: &#123;</span><br><span class="line">      firstname: &quot;请输入您的名字&quot;,</span><br><span class="line">      lastname: &quot;请输入您的姓氏&quot;,</span><br><span class="line">      username: &#123;</span><br><span class="line">        required: &quot;请输入用户名&quot;,</span><br><span class="line">        minlength: &quot;用户名必需由两个字母组成&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      password: &#123;</span><br><span class="line">        required: &quot;请输入密码&quot;,</span><br><span class="line">        minlength: &quot;密码长度不能小于 5 个字母&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      confirm_password: &#123;</span><br><span class="line">        required: &quot;请输入密码&quot;,</span><br><span class="line">        minlength: &quot;密码长度不能小于 5 个字母&quot;,</span><br><span class="line">        equalTo: &quot;两次密码输入不一致&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      email: &quot;请输入一个正确的邮箱&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.error&#123;</span><br><span class="line">color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form class=&quot;cmxform&quot; id=&quot;signupForm&quot; method=&quot;get&quot; action=&quot;&quot;&gt;</span><br><span class="line">  &lt;fieldset&gt;</span><br><span class="line">    &lt;legend&gt;验证完整的表单&lt;/legend&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;firstname&quot;&gt;名字&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;firstname&quot; name=&quot;firstname&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;lastname&quot;&gt;姓氏&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;lastname&quot; name=&quot;lastname&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;confirm_password&quot;&gt;验证密码&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;confirm_password&quot; name=&quot;confirm_password&quot; type=&quot;password&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;</span><br><span class="line">      &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/fieldset&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/2019/09/26/jquery-validate插件的使用/check2.png" alt></p><p>required：true 值是必须的。</p><p>required：”#aa:checked”表达式的值为真，则需要验证。</p><p>required：function(){}返回为真，表示需要验证。</p><p>后面两种常用于表单中需要同时填或不填的元素。</p><hr><h5 id="还有其他常用方法及一些注意事项就不一一说明了，详情可前往：https-www-runoob-com-jquery-jquery-plugin-validate-html"><a href="#还有其他常用方法及一些注意事项就不一一说明了，详情可前往：https-www-runoob-com-jquery-jquery-plugin-validate-html" class="headerlink" title="还有其他常用方法及一些注意事项就不一一说明了，详情可前往：https://www.runoob.com/jquery/jquery-plugin-validate.html"></a>还有其他常用方法及一些注意事项就不一一说明了，详情可前往：<a href="https://www.runoob.com/jquery/jquery-plugin-validate.html" target="_blank" rel="noopener">https://www.runoob.com/jquery/jquery-plugin-validate.html</a></h5><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;jQuery-Validate插件&quot;&gt;&lt;a href=&quot;#jQuery-Validate插件&quot; class=&quot;headerlink&quot; title=&quot;jQuery Validate插件&quot;&gt;&lt;/a&gt;jQuery Validate插件&lt;/h5&gt;&lt;hr&gt;&lt;p&gt;做JavaWeb项目时的登录注册页面等，少不了的就是我们的表单数据的验证。而传统我们可以使用ajax、JSR 303等方法来验证表单数据，而这些都是由后台人员来编写的。今天，我来给大家介绍一个前端人员也可以做出表单数据验证方法，那就是我们的JQuery Validate插件，它提供了强大的验证功能，操作也相对简单。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://fanghua-code.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="jquery validate" scheme="http://fanghua-code.github.io/tags/jquery-validate/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="http://fanghua-code.github.io/2019/09/19/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://fanghua-code.github.io/2019/09/19/hexo搭建博客/</id>
    <published>2019-09-19T11:11:48.000Z</published>
    <updated>2019-11-11T11:47:41.154Z</updated>
    
    <content type="html"><![CDATA[<h5 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h5><hr><ol><li><p>前往<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a> 下载安装node.js</p><p><img src="/2019/09/19/hexo搭建博客/nodejs.png" alt="1568892566485"></p><p>可在cmd输入node -v查看是否安装成功，若出现版本信息则安装成功</p><a id="more"></a></li><li><p>前往<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a> 下载安装Git</p><p><img src="/2019/09/19/hexo搭建博客/git.png" alt="1568892838093"></p><p>可在cmd中输入git –version查看版本信息判断是否安装成功</p></li><li><p>github账户注册配置</p></li><li><p>利用npm安装淘宝npm（cnpm）：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p><p>可在cmd输入cnpm -v查看版本信息判断是否安装成功</p><p>安装淘宝npm是因为使用npm可能会很慢</p></li><li><p>安装hexo：cnpm install -g hexo-cli</p><p>可在cmd输入hexo -v验证是否安装成功</p></li></ol><hr><h5 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h5><hr><ol><li><p>找个位置建立一个博客的总文件夹。例如我在E盘下建立了一个myblog文件夹</p><p>如果在搭建博客的过程中有问题，大不了把文件夹删除重新再来，无需畏惧</p></li><li><p>管理员打开cmd（在博客文件夹鼠标右键使用Git Bash也可以）输入hexo init</p><p>生成博客相关文件相关内容，后续对博客进行修改对相关内容进行修改即可</p><p><img src="/2019/09/19/hexo搭建博客/myblog.png" alt></p></li><li><p>切到博客文件根目录输入hexo s</p><p><img src="/2019/09/19/hexo搭建博客/hexo_s.png" alt></p></li><li><p>在本地的localhost:4000启动博客</p><p><img src="/2019/09/19/hexo搭建博客/local.png" alt></p><p>我这是已搭建好的博客，主题和初次搭建不一样</p></li><li><p>创建一篇博客文章：hexo new ‘博客文章名称’</p><p><img src="/2019/09/19/hexo搭建博客/hexo_n.png" alt></p><p>会在博客文件夹下的source下的_posts目录下生成一篇博客文章（Markdown格式）</p><p><img src="/2019/09/19/hexo搭建博客/md.png" alt></p><p>博客文章内容自己编写即可</p></li><li><p>再次生成博客：</p><p>hexo clean （清理一下）</p><p>hexo g （重新生成）</p><p>hexo s （在本地访问预览）</p></li></ol><hr><h5 id="将博客部署到github上"><a href="#将博客部署到github上" class="headerlink" title="将博客部署到github上"></a>将博客部署到github上</h5><hr><ol><li><p>登录GitHub，新建仓库</p><p><img src="/2019/09/19/hexo搭建博客/github.png" alt></p><p>注意仓库名称：github账户昵称.github.io</p><p>我这里报错是因为我已经建立了博客仓库</p><p><img src="/2019/09/19/hexo搭建博客/github_repo" alt></p></li><li><p>安装git部署插件：cnpm install –save hexo-deployer-git</p></li><li><p>安装好git部署插件后，在博客根目录找到全局配置文件</p><p><img src="/2019/09/19/hexo搭建博客/allconfig.png" alt></p><p>设置_config.yml文件，使用notepad++（最好不要使用记事本打开）打开，找到deploy，设置type为git，添加github博客仓库地址repo以及branch</p><p><img src="/2019/09/19/hexo搭建博客/changeconfig.png" alt></p><p>注：冒号后面有一个空格</p></li><li><p>命令行输入hexo d部署到github</p><p><img src="/2019/09/19/hexo搭建博客/togithub.png" alt></p><p>这样就将博客部署到github上去了，以后就可以通过访问博客仓库名直接访问到我们的博客了</p></li></ol><hr><h5 id="博客文章引入图片问题"><a href="#博客文章引入图片问题" class="headerlink" title="博客文章引入图片问题"></a>博客文章引入图片问题</h5><hr><ol><li><p>本地引入图片路径问题：</p><ol><li><p>如果在未下载引入图片相关插件时，图片路径会乱码，导致在博客文章中无法显示图片</p></li><li><p>解决：</p><ol><li><p>安装引入图片插件：</p><p>cnpm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save</p></li><li><p>打开全局_config.yml将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></p><p><img src="/2019/09/19/hexo搭建博客/imgconfig.png" alt></p></li><li><p>运行hexo new ‘xxx’后会在posts目录下同时生成一个与博客文章同名的文件夹，将图片放在该文件夹里（直接放在文件夹内，不需要在里面再建文件夹放置）</p></li><li><p>在博客文章中想添加图片的位置写入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](/图片名称.图片格式)  //如![](/image.png)</span><br></pre></td></tr></table></figure></li></ol></li></ol></li></ol><pre><code>5. 在博客根目录打开cmd输入hexo g和hexo s在本地预览查看</code></pre><hr>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h5&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;前往&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/en/&lt;/a&gt; 下载安装node.js&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/09/19/hexo搭建博客/nodejs.png&quot; alt=&quot;1568892566485&quot;&gt;&lt;/p&gt;
&lt;p&gt;可在cmd输入node -v查看是否安装成功，若出现版本信息则安装成功&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hexo博客" scheme="http://fanghua-code.github.io/categories/hexo%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://fanghua-code.github.io/tags/hexo/"/>
    
      <category term="github" scheme="http://fanghua-code.github.io/tags/github/"/>
    
  </entry>
  
</feed>
