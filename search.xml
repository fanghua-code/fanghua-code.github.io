<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二叉树]]></title>
    <url>%2F2019%2F11%2F13%2F%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树二叉树的相关概念： 每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左子节点和右子节点 如果该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n - 1（n为层数），则我们称为满二叉树 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，并且最后一层的叶子节点在左连续，倒数第二层的叶子节点在右连续，我们称为完全二叉树 二叉树的遍历 前序遍历：先输出父节点，再前序遍历左子树，最后前序遍历右子树 中序遍历：先中序遍历左子树，再输出父节点，最后中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，最后输出父节点 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** * 二叉树 * @author 沐雨 */public class BinaryTree &#123; private Node root; public BinaryTree(Node root) &#123; this.root = root; &#125; public Node getRoot() &#123; return root; &#125; /** * 前序遍历 */ public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; &#125; /** * 中序遍历 */ public void infinOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; &#125; public static void main(String[] args) &#123; //创建节点 Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); //手动生成二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); BinaryTree binaryTree = new BinaryTree(node1); binaryTree.preOrder(); System.out.println("-------------"); binaryTree.infinOrder(); System.out.println("-------------"); binaryTree.postOrder(); &#125;&#125;class Node&#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; //...setter、getter即toString方法省略 /** * 前序遍历 */ public void preOrder() &#123; //先访问当前节点 System.out.println(this); //向左子树递归遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; //向右子树递归遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 中序遍历 */ public void infixOrder() &#123; //先向左子树递归遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; //访问当前节点 System.out.println(this); //向右子树递归遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; /** * 后序遍历 */ public void postOrder() &#123; //先向左子树递归遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; //向右子树递归遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; //访问当前节点 System.out.println(this); &#125;&#125; 测试： 二叉树中节点的查找 前序遍历查找： 判断当前节点是否为所要查找的节点，若是则直接返回 否则向左递归查找，若找到则将其返回 否则向右递归查找，若找到则将其返回 中序遍历查找： 向左递归查找，若找到则将其返回 否则判断当前节点是否为所要查找的节点，若是则返回当前节点 否则向右递归查找，若找到则将其返回 后序遍历查找： 向左递归查找，若找到则将其返回 否则向右递归查找，若找到则将其返回 否则判断当前节点是否为所要查找的节点，若是则返回当前节点 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/** * 二叉树 * @author 沐雨 */public class BinaryTree &#123; private Node root; public BinaryTree(Node root) &#123; this.root = root; &#125; public Node getRoot() &#123; return root; &#125; /** * 前序遍历查找 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node preOrderSearch(int data) &#123; if (this.root != null) &#123; return this.root.preOrderSearch(data); &#125; return null; &#125; /** * 中序遍历查找 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node infixOrderSearch(int data) &#123; if (this.root != null) &#123; return this.root.infixOrderSearch(data); &#125; return null; &#125; /** * 后序遍历查找 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node postOrderSearch(int data) &#123; if (this.root != null) &#123; return this.root.postOrderSearch(data); &#125; return null; &#125; public static void main(String[] args) &#123; //创建节点 Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); //手动生成二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); BinaryTree binaryTree = new BinaryTree(node1); Node node = binaryTree.preOrderSearch(6); System.out.println(node); &#125;&#125;class Node&#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; //...setter、getter即toString方法省略 /** * 前序查找指定节点 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node preOrderSearch(int data) &#123; //判断当前节点是否为所要查找的节点 if (this.data == data) &#123; return this; &#125; Node res = null; //向左递归查找 if (this.left != null) &#123; res = this.left.preOrderSearch(data); //判断是否是否找到所要查找的节点，若是则返回该节点 if (res != null) &#123; return res; &#125; &#125; //向右递归查找 if (this.right != null) &#123; res = this.right.preOrderSearch(data); &#125; //返回最终查找结果 return res; &#125; /** * 中序遍历查找 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node infixOrderSearch(int data) &#123; Node res = null; //向左递归查找 if (this.left!= null) &#123; res = this.left.infixOrderSearch(data); if (res != null) &#123; return res; &#125; &#125; //判断当前节点是否为所要查找的节点 if (this.data == data) &#123; return this; &#125; //向右递归查找 if (this.right != null) &#123; res = this.right.infixOrderSearch(data); &#125; return res; &#125; /** * 后序遍历查找 * @param data 所要查找的节点数据 * @return 若该二叉树中存在该节点，返回该节点，否则返回null */ public Node postOrderSearch(int data) &#123; Node res = null; //向左递归查找 if (this.left != null) &#123; res = this.left.postOrderSearch(data); if (res != null) &#123; return res; &#125; &#125; //向右递归查找 if (this.right != null) &#123; res = this.right.postOrderSearch(data); &#125; //判断当前节点是否为所要查找的节点 if (this.data == data) &#123; return this; &#125; return res; &#125;&#125; 测试： 二叉树中节点的删除 说明：若要删除的节点为叶子节点，则直接将其删除；若要删除的节点为非叶子节点，则将整个子树删除 思路分析： 判断二叉树的根节点是否为空，若为空则提示二叉树为空树 若二叉树的根节点不为空，判断根节点是否为要删除的节点，若是则将根节点置空 若空节点不为空，判断左子节点是否为空 若左子节点不为空则判断左子节点是否为要删除的节点，若是则将该左子节点置空（即this.left = null），若不是则继续向左递归查找所要删除的节点 若左子节点为空则判断右子节点是否为空 若右子节点不为空则判断右子节点是否为要删除的节点，若是则将该右子节点置空（即this.right = null），若不是则继续向右递归查找所要删除的节点 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * 二叉树 * @author 沐雨 */public class BinaryTree &#123; private Node root; public BinaryTree(Node root) &#123; this.root = root; &#125; public Node getRoot() &#123; return root; &#125; /** * 前序遍历 */ public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125;else &#123; System.out.println("该二叉树为空！"); &#125; &#125; /** * 删除二叉树中指定数据的节点 * @param data 节点数据 */ public void delNode(int data) &#123; //判断该二叉树的根节点是否为空 if (this.root != null) &#123; //判断根节点是否为要删除的节点 if (this.root.getdata() == data) &#123; this.root = null; return; &#125; //根节点不是要删除的节点，调用节点删除方法 this.root.delNode(data); &#125;else &#123; System.out.println("该二叉树为空树！"); &#125; &#125; public static void main(String[] args) &#123; //创建节点 Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); //手动生成二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); BinaryTree binaryTree = new BinaryTree(node1); //删除data为5的节点 System.out.println("删除节点前的前序排列"); binaryTree.preOrder(); System.out.println("-----------"); binaryTree.delNode(5); System.out.println("删除节点后的前序排列"); binaryTree.preOrder(); &#125;&#125;class Node&#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; //...setter、getter即toString方法省略 /** * 前序遍历 */ public void preOrder() &#123; //先访问当前节点 System.out.println(this); //向左子树递归遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; //向右子树递归遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 删除指定数据的节点 * 1、如果要删除的节点是叶子节点，则直接将其删除 * 2、如果要删除的节点是非叶子节点，则将整个子树删除 * @param data 节点数据 */ public void delNode(int data) &#123; //判断当前节点的左子节点是否为空 if (this.left != null) &#123; //判断当前节点的子左节点是否为要删除的节点 if (this.left.data == data) &#123; this.left = null; return; &#125; //当前节点的左子节点不是要删除的节点，继续向左递归查找要删除的节点 this.left.delNode(data); &#125; //判断当前节点的右子节点是否为空 if (this.right != null) &#123; //判断当前节点的右子节点是否为要删除的节点 if (this.right.data == data) &#123; this.right = null; return; &#125; //当前节点的右子节点不是要删除的节点，继续向右递归查找要删除的节点 this.right.delNode(data); &#125; &#125;&#125; 测试： 思考：当要删除的节点是非叶子节点时，我们不希望将该非叶子节点为根节点的子树删除，而是判断要删除的节点是否存在子节点。 分析：若要删除的节点存在两个子节点，则让其左子节点来顶替它的位置；若要删除的节点只有一个节点，则让其子节点顶替它的位置。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** * 二叉树 * @author 沐雨 */public class BinaryTree &#123; private Node root; public BinaryTree(Node root) &#123; this.root = root; &#125; public Node getRoot() &#123; return root; &#125; /** * 前序遍历 */ public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125;else &#123; System.out.println("该二叉树为空！"); &#125; &#125; /** * 删除二叉树中指定数据的节点 * @param data 节点数据 */ public void delNode(int data) &#123; //判断该二叉树的根节点是否为空 if (this.root != null) &#123; //判断根节点是否为要删除的节点 if (this.root.getdata() == data) &#123; this.root = null; return; &#125; //根节点不是要删除的节点，调用节点删除方法 this.root.delNode(data); &#125;else &#123; System.out.println("该二叉树为空树！"); &#125; &#125; public static void main(String[] args) &#123; //创建节点 Node node1 = new Node(1); Node node2 = new Node(2); Node node3 = new Node(3); Node node4 = new Node(4); Node node5 = new Node(5); //手动生成二叉树 node1.setLeft(node2); node1.setRight(node3); node3.setRight(node4); node3.setLeft(node5); BinaryTree binaryTree = new BinaryTree(node1); //删除data为3的节点 System.out.println("删除节点前的前序排列"); binaryTree.preOrder(); System.out.println("-----------"); binaryTree.delNode(3); System.out.println("删除节点后的前序排列"); binaryTree.preOrder(); &#125;&#125;class Node&#123; private int data; private Node left; private Node right; public Node(int data) &#123; this.data = data; &#125; //...setter、getter即toString方法省略 /** * 前序遍历 */ public void preOrder() &#123; //先访问当前节点 System.out.println(this); //向左子树递归遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; //向右子树递归遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; /** * 删除指定数据的节点 * 1、如果要删除的节点是叶子节点，则直接将其删除 * 2、如果要删除的节点是非叶子节点 * 若要删除的节点只有一个子节点，则让该子节点来顶替要删除节点的位置 * 若要删除的节点有两个子节点，则让要删除节点的左节点来顶替其位置 * @param data 节点数据 */ public void delNode(int data) &#123; //辅助节点 Node temp = null; //判断当前节点的左子节点是否为空 if (this.left != null) &#123; //判断当前节点的左子节点是否为要删除的节点 if (this.left.data == data) &#123; //当前节点的左子节点为要删除的节点 temp = this.left; //判断该左子节点有多少个子节点 if (temp.left != null &amp;&amp; temp.right != null) &#123; //该左子节点有两个子节点，则该左子节点的左节点来顶替其位置 this.left = temp.left; temp.left.right = temp.right; &#125;else if (temp.left == null &amp;&amp; temp.right != null)&#123; //该左子节点只有右子节点，让其顶替该左子节点的位置 this.left = temp.right; &#125;else &#123; //该左子节点只有左子节点，让其顶替该左子节点的位置 this.left = temp.left; &#125; return; &#125; //当前节点的左子节点不是要删除的节点 this.left.delNode(data); &#125; if (this.right != null) &#123; if (this.right.data == data) &#123; temp = this.right; if (temp.left != null &amp;&amp; temp.right != null) &#123; this.right = temp.left; temp.left.right = temp.right; &#125;else if (temp.left == null &amp;&amp; temp.right != null) &#123; this.right = temp.right; &#125;else &#123; this.right = temp.left; &#125; return; &#125; this.right.delNode(data); &#125; &#125;&#125; 测试：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈希表]]></title>
    <url>%2F2019%2F11%2F11%2F%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[哈希表 基本介绍： 散列表（hash table，也叫哈希表），是根据关键码值（Key value）而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。 实际需求： 有一个公司，当有新员工来报道时，要求将该员工的信息加入到{id, 性别, 年龄, 住址……}，当输入该员工的id时，要求查找到该员工的所有信息。 要求：不使用数据库，尽量节省内存，速度越快越好 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/** * 哈希表 * @author 沐雨 */public class HashTable &#123; private EmpLinkedList[] EmpLinkedListArray; public HashTable(int size) &#123; EmpLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; EmpLinkedListArray.length; i++) &#123; EmpLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; /** * 将新员工添加到hash表中 * @param emp 新员工 */ public void add(Emp emp) &#123; int hashId = hash(emp.id); EmpLinkedListArray[hashId].add(emp); &#125; /** * 获得指定员工id应该加入到hash表中的哪一条链表中 * @param id 新员工id * @return 链表id */ public int hash(int id) &#123; return id % EmpLinkedListArray.length; &#125; /** * 遍历hash表 */ public void list() &#123; for (int i = 0; i &lt; EmpLinkedListArray.length; i++) &#123; EmpLinkedListArray[i].list(i); &#125; &#125; public Emp find(int id) &#123; int hashId = hash(id); return EmpLinkedListArray[hashId].find(id); &#125; /** * 删除hash表中指定id的员工 * @param id 员工id */ public void delete(int id) &#123; int hashId = hash(id); EmpLinkedListArray[hashId].delete(id); &#125; public static void main(String[] args) &#123; HashTable hashTable = new HashTable(5); Scanner sc = new Scanner(System.in); String key = ""; while (true) &#123; System.out.println("add：添加员工信息"); System.out.println("list：查询所有员工信息"); System.out.println("find：查找指定员工信息"); System.out.println("delete：删除指定员工"); System.out.println("exit：退出系统"); key = sc.next(); switch (key) &#123; case "add": System.out.println("请输入id："); int id = sc.nextInt(); System.out.println("请输入姓名："); String name = sc.next(); Emp emp = new Emp(id, name); hashTable.add(emp); break; case "list": hashTable.list(); break; case "find": System.out.println("请输入员工id："); int findId = sc.nextInt(); try &#123; Emp emp1 = hashTable.find(findId); System.out.println(emp1); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case "delete": System.out.println("请输入员工id"); int empId = sc.nextInt(); hashTable.delete(empId); break; case "exit": sc.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;class EmpLinkedList&#123; //头节点，指向链表中第一个员工 private Emp head; /** * 判断新员工链表是否为空 * @return 若链表为空返回true，反之返回false */ public boolean isEmpty() &#123; return head == null; &#125; /** * 往新员工链表中添加员工信息 * @param emp 员工节点 */ public void add(Emp emp) &#123; if (isEmpty()) &#123; head = emp; return; &#125; Emp temp = head; while (temp.next != null) &#123; temp = temp.next; &#125; temp.next = emp; &#125; /** * 遍历员工链表 */ public void list(int i) &#123; if (isEmpty()) &#123; System.out.println("第" + i + "条链表暂无新员工信息！"); return; &#125; Emp temp = head; System.out.print("第" + i + "条链表员工信息为"); do &#123; System.out.print(" ==&gt; " + temp); temp = temp.next; &#125;while (temp != null); System.out.println(); &#125; /** * 查找指定id的员工信息 * @param id 员工id * @return 若该链表中存在该id员工，返回该员工信息，反之抛出异常 */ public Emp find(int id) &#123; if (isEmpty()) &#123; throw new RuntimeException("该链表为空！"); &#125; Emp temp = head; while (temp != null) &#123; if (temp.id == id) &#123; return temp; &#125; temp = temp.next; &#125; throw new RuntimeException("该链表暂无该员工信息！"); &#125; /** * 删除指定id的员工 * @param id 员工id */ public void delete(int id) &#123; if (isEmpty()) &#123; System.out.println("该链表为空！"); return; &#125; Emp temp = head; //判断要删除的员工信息是否位于链表第一个元素 if (temp.id == id) &#123; Emp cur = temp; temp = temp.next; cur.next = null; head = temp; &#125;else &#123; while (temp.next != null &amp;&amp; temp.next.id != id) &#123; temp = temp.next; &#125; Emp cur = temp.next; if (cur == null) &#123; System.out.println("该链表无该员工信息！"); &#125;else &#123; temp.next = cur.next; &#125; &#125; &#125;&#125;class Emp&#123; public int id; public String name; public Emp next; public Emp(int id, String name) &#123; this.id = id; this.name = name; &#125; @Override public String toString() &#123; return "Emp&#123;" + "id=" + id + ", name='" + name + '\'' + '&#125;'; &#125;&#125; 测试哈希表： 添加新员工信息到散列表： 查询所有员工信息： 查询指定id员工信息： 删除指定id员工信息：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找算法]]></title>
    <url>%2F2019%2F11%2F11%2F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查找算法常用的查找算法 在java中，我们常用到的算法有四种： 顺序（线性）查找 二分（折半）查找 插值查找 斐波那契查找 顺序查找 ​ 顺序查找是最简单的查找方式，直接通过遍历序列来查找指定值，这种查找方式对序列不做要求，但查找效率低 12345678910111213141516171819202122232425262728/** * 线性查找 * @author 沐雨 */public class SeqSearch &#123; /** * 线性查找数组中的值，找到返回下标，找不到返回-1 * 若数组中存在多个要查找的值，则返回排在前面要查找的值的下标 * @param arr 查找的数组 * @param value 需要查找的值 * @return 需要查找的值的下标 */ public static int search(int[] arr, int value) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == value) &#123; return i; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; //测试线性查找 int[] arr = &#123;-1, 10, 8, 3, 6, 4&#125;; int index = SeqSearch.search(arr, 4); System.out.println(index); &#125;&#125; ​ 测试： ​ 二分查找 二分查找也称折半查找（Binary Sort），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 算法要求： 必须采用顺序存储结构 必须按关键字大小有序排列 应用实例： 请对一个有序数组进行二分查找{1, 8, 10, 89, 1000, 1234}，输入一个数看数组是否存在此数，并且求出下标，如果没有就提示“没有这个数”。 思路分析： 首先确定该数组的中间元素的下标：mid = (left + right) / 2 然后让需要查找的值val和arr[mid]进行比较 如果val &gt; arr[mid] ，说明要查找的值在arr[mid]的右边，于是向右边进行递归查找 如果val &lt; arr[mid] ，说明要查找的值在arr[mid]的左边，于是向左边进行递归查找 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839/** * 二分查找 * 注：查找序列一定是有序的 * @author 沐雨 */public class BinarySearch &#123; /** * 二分查找算法（不考虑序列中有多个所要查找的值） * @param arr 查找序列 * @param left 左边的索引 * @param right 右边的索引 * @param val 要查找的值 * @return 若序列中存在要查找的值，返回下标，否则返回-1 */ public static int search(int[] arr, int left, int right, int val) &#123; if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int pivot = arr[mid]; if (val &gt; pivot) &#123; //向右递归 return search(arr, mid + 1, right, val); &#125;else if (val &lt; pivot) &#123; //向左递归 return search(arr, left, mid - 1, val); &#125;else &#123; return mid; &#125; &#125; public static void main(String[] args) &#123; //测试二分查找 int[] arr = &#123;1, 8, 10, 89, 1000, 1234&#125;; int index = search(arr, 0, arr.length - 1, 1234); System.out.println(index); &#125;&#125; 测试： ​ 思考：{1, 8, 10, 89, 1000, 1000, 1000, 1234}当一个有序数组中有多个相同的数值时，如何将所有的数值都查找到，比如这里的1000 分析：在找到所要查找的数值时，往该数值的左右进行扫描，查看是否还存在其他该数值的元素，将这些元素的下标存入List集合并返回 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 二分查找 * 注：查找序列一定是有序的 * @author 沐雨 */public class BinarySearch &#123; /** * 二分查找算法（考虑序列中存在多个所要查找的值） * @param arr 查找序列 * @param left 左边的索引 * @param right 右边的索引 * @param val 要查找的值 * @return 若序列中存在要查找的值，将所有该值的下标放入List集合中并返回。否则返回空集合 */ public static List&lt;Integer&gt; search(int[] arr, int left, int right, int val) &#123; if (left &gt; right) &#123; return new ArrayList&lt;Integer&gt;(); &#125; List&lt;Integer&gt; resIndexList = new ArrayList&lt;Integer&gt;(); int mid = (left + right) / 2; int pivot = arr[mid]; if (val &gt; pivot) &#123; //向右递归 return search(arr, mid + 1, right, val); &#125;else if (val &lt; pivot) &#123; //向左递归 return search(arr, left, mid - 1, val); &#125;else &#123; resIndexList.add(mid); int temp = mid - 1; //向左扫描，查看是否还存在需要查找的val while (temp &gt;= left &amp;&amp; arr[temp] == val) &#123; resIndexList.add(temp); temp --; &#125; temp = mid + 1; //向右扫描，查看是否还存在需要查找的val while (temp &lt;= right &amp;&amp; arr[temp] == val) &#123; resIndexList.add(temp); temp ++; &#125; return resIndexList; &#125; &#125; public static void main(String[] args) &#123; //测试二分查找 int[] arr = &#123;1, 8, 10, 89, 1000, 1000, 1000, 1234&#125;; List&lt;Integer&gt; indexs = search(arr, 0, arr.length - 1, 1000); System.out.println(indexs); &#125;&#125; 测试： ​ 插值查找 原理介绍： 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找 将折半查找中的mid索引的公式进行改进： mid = low + (high - low) * (val - arr[low]) / (arr[high] - arr[low]) 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 插入查找 * @author 沐雨 */public class InsertValueSearch &#123; /** * 插入查找算法（不考虑数组中存在多个序偶要查找的值） * @param arr 查找数组 * @param low 左边的索引 * @param high 右边的索引 * @param val 所要查找的值 * @return 若数组中存在所要查找的值，返回下标，否则返回-1 */ public static int search(int[] arr, int low, int high, int val) &#123; System.out.println("hello"); if (low &gt; high || val &lt; arr[0] || val &gt;arr[arr.length - 1]) &#123; return -1; &#125; int mid = low + (high - low) * (val - arr[low]) / (arr[high] - arr[low]); int pivot = arr[mid]; if (val &gt; pivot) &#123; //向右递归 return search(arr, mid + 1, high, val); &#125;else if (val &lt; pivot) &#123; //向左递归 return search(arr, low, mid - 1, val); &#125;else &#123; return mid; &#125; &#125; public static void main(String[] args) &#123; //测试插入查找 int[] arr = new int[100]; for (int i = 0; i &lt; 100; i++) &#123; arr[i] = i + 1; &#125; int index = InsertValueSearch.search1(arr, 0, arr.length - 1, 1); System.out.println(index); &#125;&#125; 测试： ​ 在数组{1, 2, 3……, 100}中查找1和38，比较二分查找和插值查找（在两个查找方法中第一行输出hello查看查找所需次数 插值查找注意事项： 对于数据量较大，关键字分布比较均匀的查找序列来说，采用插值查找速度较快 关键字分布不均匀的情况下，该方法不一定比折半查找要好 斐波那契（黄金分割法）查找算法 基本介绍： 黄金分割点是指一条线段分割为两部分，使其中一部分与全长之比等于另一部分之比。取其前三位数字的近似值时0.618.由于按此比例设计的造型十分美丽，因此称为黄金分割，也称中外比。这是一个神奇的数字，会带来意想不到的效果 斐波那契数列{1, 1, 2, 3, 5, 8, 13, 21, 34, 55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618. 斐波那契原理： 斐波那契查找原理与前两种相似，仅仅改变了mid的位置，mid不再是中间或插值得到。而是位于黄金分割点附近，即mid = low + F(k - 1) - 1（F表示斐波那契数列） 对F(k - 1) - 1的理解 有斐波那契数列F[k] = F[k - 1] + F[k - 2]的性质。可以得到(F[k] - 1) = (F[k - 1] - 1) + (F[k - 2] - 1) + 1。该试说明，只要顺序表的长度为F[K] - 1，则可以将该表分成长度为F[k - 1] - 1和F[k - 2] - 1的两段，即如上图所示。从而中间位置为mid = low + F(k - 1) - 1 类似的，每一子段也可以用相同的方法分割 但顺序表长度n不一定刚好等于F[k] - 1，所以需要将原来的顺序表长度n增加至F[k] - 1.这里的K值只要能使得F[k] - 1恰好大于或等于n即可，由以下代码得到顺序表长度增加后，新增的位置（从n + 1到F[k] - 1位置），都赋为n位置的值即可。 123while(n &gt; fib(k) - 1) &#123; k++;&#125; 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 斐波那契查找 * @author 沐雨 */public class FibonacciSearch &#123; private static int maxSize = 20; /** * 得到一个指定大小的斐波那契数列 * @return 斐波那契数列 */ public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; /** * 斐波那契查找方法（非递归方法） * @param arr 查找序列 * @param val 所要查找的值 * @return 若查找序列中存在所要查找的值，返回下标，否则返回-1 */ public static int search(int[] arr, int val) &#123; //左边索引 int low = 0; //右边索引 int high = arr.length - 1; //中间索引 int mid = 0; //斐波那契数列的黄金分割点 int k = 0; int[] F = fib(); //找到时数组长度恰好小于等于F[k] - 1的k值 while (high &gt; F[k] - 1) &#123; k ++; &#125; //将数组扩充为长度F[k]的数组 int[] temp = Arrays.copyOf(arr, F[k]); for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = arr[high]; &#125; while (low &lt;= high) &#123; mid = low + F[k - 1] - 1; if (val &lt; temp[mid]) &#123; high = mid - 1; k -= 1; &#125;else if (val &gt; temp[mid]) &#123; low = mid + 1; k -= 2; &#125;else &#123; if (mid &lt;= high) &#123; return mid; &#125;else &#123; return high; &#125; &#125; &#125; return -1; &#125; public static void main(String[] args) &#123; //测试斐波那契查找 int[] arr = &#123;1, 8, 10, 1000, 1234&#125;; int index = search(arr, 1); System.out.println(index); &#125;&#125; 测试： ​]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F11%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[排序算法 排序算法的介绍： 排序也称为排序算法（Sort Algorithm），排序时将一组数据进行排列的过程。 排序的分类： 内部排序法（使用内存）：直降需要处理的素有数据都加载到内部存储器中进行排序 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部储存进行排序 常见的时间复杂度： 常见算法的比较情况： 冒泡排序 基本介绍： 冒泡排序的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒。 因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 冒泡排序 * @author 沐雨 */public class BubbleSort &#123; /** * 冒泡排序方法 * @param arr 需要排序的数组 */ public static void sort(int[] arr) &#123; boolean flag = false; int temp = 0; for (int i = 1; i &lt; arr.length; i++) &#123; flag = false; for (int j = 0; j &lt; arr.length - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if (!flag) &#123; break; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;3, 9, -1, 10, -2&#125;; BubbleSort.sort(arr); System.out.println(Arrays.toString(arr)); //测试冒泡排序的速度 int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; long t1 = System.currentTimeMillis(); BubbleSort.sort(testArr); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / (float) 1000); &#125;&#125; 测试： 选择排序 基本介绍：选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一个元素，再依规定交换位置后达到排序的目的。 选择排序思想：第一次从arr[0]到arr[n - 1]中选取最小值，与arr[0]交换，第二次从arr[1]到arr[n - 1]中选取最小值，与arr[1]交换……第i次从arr[i - 1]到arr[n - 1]中选取最小值，与arr[i - 1]交换……第n - 1次从arr[n - 2]到arr[n - 1]中选取最小值，与arr[n - 2]交换，总共通过n - 1次，得到一个按排序码从小到大排序的有序序列。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 选择排序 * @author 沐雨 */public class SelectedSort &#123; /** * 选择排序方法 * @param arr 需要排序的数组 */ public static void sort(int[] arr) &#123; int temp = 0; int minIndex = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; minIndex = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; minIndex = j; &#125; &#125; if (i != minIndex) &#123; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; &#125; &#125; public static void main(String[] args) &#123; //测试选择排序 int[] arr = &#123;10, 81, 64, 34, 45&#125;; SelectedSort.sort(arr); System.out.println(Arrays.toString(arr)); //测试选择排序的速度 int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; long t1 = System.currentTimeMillis(); SelectedSort.sort(testArr); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 插入排序 基本介绍：插入式排序属于内部排序法，是对欲排序的元素以插入的方式找寻该元素的适当位置，已达到排序的目的。 插入排序思想：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含n - 1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码一次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 插入排序 * @author 沐雨 */public class InsertSort &#123; /** * 插入排序方法 * @param arr 需要排序的数组 */ public static void sort(int[] arr) &#123; //定义待插入的值和待插入值的位置下标 int insertVal = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i - 1; //通过while循环找到要插入的元素的位置 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; //当退出循环后，insertIndex + 1就是要插入元素的位置 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;17, 3, 25, 14, 20, 9&#125;; InsertSort.sort(arr); System.out.println(Arrays.toString(arr)); //测试插入排序的速度 int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; long t1 = System.currentTimeMillis(); InsertSort.sort(testArr); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 存在问题：当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响。 希尔排序 基本介绍：希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序基本思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰好分成一组，算法变终止。 注： 希尔排序时，对有序序列在插入时采用交换法，排序速度相对较低，但相对好理解 希尔排序时，对有序序列在插入时采用移动法，排序速度相对较高，但相对难理解 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 希尔排序 * @author 沐雨 */public class ShellSort &#123; /** * 希尔排序方法(交换法) * @param arr 需要排序的数组 */ public static void sort1(int[] arr) &#123; int temp = 0; int r = arr.length / 2; while (r &gt;= 1) &#123; for (int i = r; i &lt; arr.length; i++) &#123; for (int j = i - r; j &gt;= 0 ; j -= r) &#123; if (arr[j] &gt; arr[j + r]) &#123; temp = arr[j]; arr[j] = arr[j + r]; arr[j + r] = temp; &#125; &#125; &#125; r /= 2; &#125; &#125; /** * 希尔排序方法(移位法) * @param arr 需要排序的数组 */ public static void sort2(int[] arr) &#123; int temp = 0; int index = 0; for (int gap = arr.length / 2; gap &gt;= 1; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i ++) &#123; index = i; temp = arr[index]; while (index - gap &gt;= 0 &amp;&amp; temp &lt; arr[index - gap]) &#123; arr[index] = arr[index - gap]; index -= gap; &#125; if (index != i) &#123; arr[index] = temp; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; //测试希尔排序 int[] arr = &#123;5, 8, 3, -1, 7, 3, -5, 4&#125;; //ShellSort.sort1(arr); ShellSort.sort2(arr); System.out.println(Arrays.toString(arr)); //测试希尔排序你的速度 int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; long t1 = System.currentTimeMillis(); //ShellSort.sort1(testArr); ShellSort.sort2(testArr); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 快速排序 基本介绍：快速排序（Quicksort）是对冒泡排序的一种改进。 快速排序思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * 快速排序 * @author 沐雨 */public class QuickSort &#123; /** * 快速排序方法 * @param arr 需要排序的数组 */ public static void sort(int[] arr, int low, int high) &#123; int temp = 0; //选择中间某个元素作为基准 int pivot = arr[(high + low) / 2]; int left = low; int right = high; while (left &lt; right) &#123; //从左边往中间找比基准元素大的元素 while (arr[left] &lt; pivot) &#123; left ++; &#125; //从右边往中间找比基准元素小的元素 while (arr[right] &gt; pivot) &#123; right --; &#125; //当left不等于right，即左边存在比基准元素大的元素或右边存在比基准元素小的元素 if (left != right) &#123; //交换 temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; if (arr[left] == pivot) &#123; right --; &#125; if (arr[right] == pivot) &#123; left ++; &#125; &#125; &#125; //向左边递归 if (right - 1 &gt; low) &#123; sort(arr, low, right - 1); &#125; //向右边递归 if (left + 1 &lt; high) &#123; sort(arr, left + 1, high); &#125; &#125; public static void main(String[] args) &#123; //测试快速排序 int[] arr = &#123;-9, 78, 0, 23, -567, 70, -1, 900, 4510&#125;; QuickSort.sort(arr, 0, arr.length - 1); System.out.println(Arrays.toString(arr)); //测试快速排序的速度 int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; long t1 = System.currentTimeMillis(); QuickSort.sort(testArr, 0, testArr.length - 1); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 归并排序 基本介绍：归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）。 归并排序思想： 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * 归并排序 * @author 沐雨 */public class MergeSort &#123; /** * 拆分数组，然后合并数组 * @param arr 需要排序的数组 * @param left 数组的左边第一个元素下标 * @param right 数组的右边最后一个元素下标 */ public static void sort(int[] arr, int left, int right, int[] temp) &#123; int mid = 0; if (left &lt; right) &#123; mid = (left + right) / 2; sort(arr, left, mid, temp); sort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; /** * 归并拆分后的数组 * @param arr 原始的数组 * @param left 拆分后左边的开始索引 * @param mid 拆分后左边的结束索引 * @param right 拆分后右边的结束索引 * @param temp 中转数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; int j = mid + 1; int t = 0; //将左右两边的数据按照从小到大填充到temp中，直到有一边填充完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; //将左右两边较小的数填充到temp中 if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t ++; i ++; &#125;else &#123; temp[t] = arr[j]; t ++; j ++; &#125; &#125; //将左右两边其中剩余一边的剩余数据依次填充到temp while (i &lt;= mid) &#123; temp[t] = arr[i]; t ++; i ++; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t ++; j ++; &#125; //将temp中的数据复制到原始数组中 t = 0; int tempLeft = left; while (tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t ++; tempLeft ++; &#125; &#125; public static void main(String[] args) &#123; //测试归并排序 int[] arr = &#123;3, 5, 4, -1, 10, 7, -8&#125;; int[] temp = new int[arr.length]; MergeSort.sort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); int[] testArr = new int[80000]; for (int i = 0; i &lt; testArr.length; i++) &#123; testArr[i] = (int) (Math.random() * 800000); &#125; int[] testTemp = new int[testArr.length]; long t1 = System.currentTimeMillis(); MergeSort.sort(testArr, 0, testArr.length - 1, testTemp); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 基数排序 基本介绍： 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶排序”（bucket sort 或 bin sort），顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用。 基数排序时属于稳定性的排序，基数排序法是效率高的稳定性排序法。 基数排序是桶排序的扩展。 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序思想：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序序列。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 基数排序 * @author 沐雨 */public class RadixSort &#123; /** * 基数排序方法 * @param arr 需要排序的数组 */ public static void sort(int[] arr) &#123; //定义一个二维数组，表示10个桶，每个桶就是一个一维数组 int[][] bucket = new int[10][arr.length]; //定义一个一维数组来记录各个桶的每次存放的数据个数 int[] bucketElementCounts = new int[bucket.length]; //得到数组中最大数的位数 int max = arr[0]; for (int item : arr) &#123; if (item &gt; max) &#123; max = item; &#125; &#125; int maxLength = (max + "").length(); for (int i = 0; i &lt; maxLength; i++) &#123; for (int value : arr) &#123; //获取数组中每一个数据的digitOfElement位数 int digitOfElement = (int) ((value / (Math.pow(10, i))) % 10); //根据个位数将该数据放入指定的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = value; bucketElementCounts[digitOfElement]++; &#125; //按照的桶的顺序（一维数组的下标）依次取出数据，放入原来的数组 int index = 0; for (int j = 0; j &lt; bucket.length; j++) &#123; //判断桶中是否有数据 if (bucketElementCounts[j] != 0) &#123; //桶中有数据 for (int k = 0; k &lt; bucketElementCounts[j]; k++) &#123; //取出元素，放入原数组 arr[index++] = bucket[j][k]; &#125; &#125; //将每个桶对应的数据个数的数组置零 bucketElementCounts[j] = 0; &#125; &#125; &#125; public static void main(String[] args) &#123; int[] arr = &#123;53, 3, 542, 748, 14, 214&#125;; RadixSort.sort(arr); System.out.println(Arrays.toString(arr)); //测试基数排序的速度 //试想，如果是80000000需要多大的内存： //80000000 * 10 * 4 / 1024/ 1024 / 1024 = 2.98 G int[] testArr = new int[80000]; long t1 = System.currentTimeMillis(); RadixSort.sort(testArr); long t2 = System.currentTimeMillis(); System.out.println((t2 - t1) / 1000.0); &#125;&#125; 测试： 注：基数排序会耗费额外的内存，如果需要排序的个数过多，会抛出内存不足的异常 基数排序的说明： 基数排序是对桶排序的扩展，速度很快。 基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成OutOfMemoryError。 基数排序是稳定的。【注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i] = r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法时稳定的，否则称为不稳定的】。 有负数的数组，我们不用基数排序来进行排序，如果要支持负数，参考：https://code.i-harness.com/zh-CN/q/e98fa9 以上排序算法的对比 在对长度为80000的数组进行排序时，以上排序算法个消耗时间为： 冒泡排序： 选择排序： 插入排序： 希尔排序： 快速排序： 归并排序： 基数排序：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归回溯]]></title>
    <url>%2F2019%2F11%2F05%2F%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%2F</url>
    <content type="text"><![CDATA[递归回溯递归 基本概念：递归就是方法自己调用自己，每次调用时都传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁 递归能用于解决什么样的问题 各种数学问题：八皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题（google编程大赛） 各种算法中也会使用到递归，比如：快排、归并排序、二分查找、分治算法等 将用栈解决的问题 ==》递归代码比较简洁 递归需要遵循的重要规则 执行方法时，就创建一个新的受保护的独立空间（栈空间） 方法的局部变量时独立的不会互相影响 递归必须向退出递归的条件逼近，否则就是无限递归 当一个方法执行完毕，或者遇到return，就会返回，遵循谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕 迷宫问题 分析： 将迷宫地图映射成一个二维数组 二维数组中用1表示迷宫的墙、2表示出迷宫的通路，3表示走过的路，但走不通，0表示还未走过的路 自定义一个寻找通路的策略，如：下 ==》右 ==》上 ==》左 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * 迷宫回溯问题 * @author 沐雨 */public class MiGong &#123; public static void main(String[] args) &#123; //创建一个数组，模拟迷宫 //地图 int[][] map = new int[8][7]; //用1表示墙 //上下全置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //左右全置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置额外的墙 map[3][1] = 1; map[3][2] = 1; //输出地图 for (int[] row : map) &#123; for (int item : row) &#123; System.out.print(item + "\t"); &#125; System.out.println(); &#125; System.out.println("-------------------------"); //调用递归函数给小球找路 //setWay(map, 1, 1); setWay2(map, 1, 1); //输出路线 for (int[] row : map) &#123; for (int item : row) &#123; System.out.print(item + "\t"); &#125; System.out.println(); &#125; &#125; /** * 使用递归回溯来给小球找路 * 说明： * 1、map表示迷宫地图 * 2、i、j表示从地图的哪一个位置开始出发（1,1），小球到达map[6][5]的位置 * 3、约定：当map[i][j]为0时表示该点没有走过，为1表示墙，2表示通路可以走，3表示该点已经走过，但是走不通 * 4、在走迷宫时，需要确定一个策略（方法）：下 ==》右 ==》上 ==》左，如果走不通，再回溯 * @param map 地图 * @param i 出发的位置横坐标，从0开始 * @param j 出发的位置纵坐标，从0开始 * @return 如果找到出迷宫的通路，则返回true，反之则返回false */ public static boolean setWay1(int[][] map, int i, int j) &#123; //判断通路是否找到 if (map[6][5] == 2) &#123; //通路已找到，返回true return true; &#125;else &#123; //通路未找到，按照策略来寻找通路：下 ==》右 ==》上 ==》左 if (map[i][j] == 0) &#123; //这个位置还没走过 map[i][j] = 2; if (setWay1(map, i + 1, j)) &#123; //表示往该位置的下方走，找到通路并返回true return true; &#125;else if (setWay1(map, i , j + 1)) &#123; //表示往该位置的右方走，找到通路并返回true return true; &#125;else if (setWay1(map, i - 1, j)) &#123; //表示往该位置的上方走，找到通路并返回true return true; &#125;else if (setWay1(map, i, j - 1)) &#123; //表示往该位置的左方走，并找到通路返回true return true; &#125;else &#123; //表示该点走不通，将该位置置为3，表示走不通 map[i][j] = 3; return false; &#125; &#125;else &#123; //该位置不为0时，可能为1、2、3 return false; &#125; &#125; &#125; /** * 修改找路的策略：上 ==》右 ==》下 ==》左 * @param map 地图 * @param i 出发的位置横坐标，从0开始 * @param j 出发的位置纵坐标，从0开始 * @return 如果找到出迷宫的通路，则返回true，反之则返回false */ public static boolean setWay2(int[][] map, int i, int j) &#123; //判断通路是否找到 if (map[6][5] == 2) &#123; //通路已找到，返回true return true; &#125;else &#123; //通路未找到，按照策略来寻找通路：下 ==》右 ==》上 ==》左 if (map[i][j] == 0) &#123; //这个位置还没走过 map[i][j] = 2; if (setWay2(map, i - 1, j)) &#123; //表示往该位置的上方走，找到通路并返回true return true; &#125;else if (setWay2(map, i , j + 1)) &#123; //表示往该位置的右方走，找到通路并返回true return true; &#125;else if (setWay2(map, i + 1, j)) &#123; //表示往该位置的下方走，找到通路并返回true return true; &#125;else if (setWay2(map, i, j - 1)) &#123; //表示往该位置的左方走，并找到通路返回true return true; &#125;else &#123; //表示该点走不通，将该位置置为3，表示走不通 map[i][j] = 3; return false; &#125; &#125;else &#123; //该位置不为0时，可能为1、2、3 return false; &#125; &#125; &#125;&#125; 测试： 八皇后问题 问题介绍：在8X8格子的国际象棋上摆放八个皇后，使其不能互相攻击。即：任意两个皇后都不能处于同一行、同一列或同一斜线上、问有多少种摆法。 思路分析： 第一个皇后先放在第一行第一列 第二个皇后放在第二行第一列，然后判断该位置是否可以摆放，如果不可以摆放，继续放在第二列、第三列。。。依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列。。。知道第八个皇后也能放在一个不冲突的位置，算是找到了一个正解 当得到第一个正解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后放到第一列的所有正解，全部得到 然后回头继续第一个皇后放在第二列，后面继续循环执行1、2、3、4的步骤 说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题。arr[8] = {0, 4, 7, 5, 2, 6, 1, 3}arr下标表示第几行，即第几个皇后，arr[i]表示第i+1个皇后放在第i+1行的地arr[i] + 1列 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 八皇后问题 * @author 沐雨 */public class xQueen &#123; //定义一个变量表示八个皇后 private int max = 8; //定义一个一维数组，保存八皇后放置位置的结果，如：arr = &#123;0, 4, 7, 5, 2, 6, 1, 3&#125; private int[] arr = new int[max]; //八皇后的解法 private static int count = 0; /** * 将皇后的摆放情况输出，即将一位数组输出 */ public void print() &#123; count++; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + "\t"); &#125; System.out.println(); &#125; /** * 判断当我们放置第n个皇后时该皇后是否与之前放置的皇后相冲突 * @param n 第n个皇后 * @return 当第n个皇后与之前反置的皇后相冲突时，返回false，不冲突时返回true */ public boolean judge(int n) &#123; for (int i = 0; i &lt; n - 1; i++) &#123; /** * arr[i] == arr[n - 1] 判断第n个皇后是否和之前摆放的皇后在同一列 * Math.abs(n - 1 - i) == Math.abs(arr[n - 1] - arr[i] 判断第n个皇后是否和之前摆放的皇后在同一斜线 */ if (arr[i] == arr[n - 1] || Math.abs(n - 1 - i) == Math.abs(arr[n - 1] - arr[i])) &#123; //第n个皇后和之前摆放的皇后在同一列或者在同一斜线，返回false return false; &#125; &#125; return true; &#125; /** * 放置第n个皇后 * @param n 第n个皇后 */ public void place(int n) &#123; //判断八个皇后是否全部放置完成 if (n - 1 == max) &#123; print(); return; &#125; //放入皇后，并判断是否冲突 for (int i = 0; i &lt; max; i++) &#123; arr[n - 1] = i; if (judge(n)) &#123; //放置皇后位置不冲突，摆放下一个皇后 place(n + 1); &#125; &#125; &#125; public static void main(String[] args) &#123; //测试八皇后问题 xQueen queen = new xQueen(); queen.place(1); System.out.printf("一共有%d种解法", xQueen.count); &#125;&#125; 测试：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组和队列]]></title>
    <url>%2F2019%2F11%2F03%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[稀疏数组和队列 稀疏数组：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组 处理方法： 记录数组一共几行几列，有多少个不为0的元素 把 不为0的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 应用实例： 使用稀疏数组来保留非0元素较多的二维数组（棋盘、地图等等） 把稀疏数组存盘，并且可以重新恢复为原来的二维数组 分析： 二维数组 ==》稀疏数组 遍历原始的二维数组，得到有效数据（非0元素）的个数sum 根据sum就可以创建稀疏数组sparseArr int[sum+1][3] 将二维数组的有效数据存入到稀疏数组 稀疏数组 ==》二维数组 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 再读取稀疏数组后几行的数据，并赋给原始二维数组即可 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 二维数组与稀疏数组的转换（这里以棋盘的存档与读档为例） * @author 沐雨 */public class SparseArrDemo &#123; public static void main(String[] args) &#123; //0、先创建原始的11x11的二维数组，0表示没有棋子，1表示黑子，2表示白子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; //棋盘第二行第三列有一颗黑子 chessArr1[2][3] = 2; //棋盘第三行第四列有一颗白子 //遍历原始数组 for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; //1、二维数组 ==》稀疏数组 //遍历原始二维数组，获取非0元素个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; //创建稀疏数组 int sparseArr[][] = new int[sum + 1][3]; //给稀疏数组第一行赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; int count = 0; //用于记录第几个非0数据 //遍历原始数组，将非0元素添加到稀疏数组中 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println("得到的稀疏数组的形式："); for (int[] row : sparseArr) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; System.out.println("-----------------------------------------"); //2、稀疏数组 ==》文件 OutputStream out = null; PrintStream ps = null; try &#123; out = new FileOutputStream("map.txt"); ps = new PrintStream(out); for (int i = 0; i &lt; sparseArr.length; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ps.print(sparseArr[i][j] + ","); &#125; ps.println(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; ps.close(); try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //3、文件 ==》稀疏数组 String arr1[] = new String[sum + 1]; int arr2[][] = new int[sum + 1][3]; BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader("map.txt")); String line = null; int i = 0; while ((line = reader.readLine()) != null) &#123; arr1[i] = line; i++; &#125; for (int j = 0; j &lt; sum + 1; j++) &#123; String[] split = arr1[j].split(","); for (int k = 0; k &lt; split.length; k++) &#123; arr2[j][k] = Integer.parseInt(split[k]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; for (int[] row : arr2) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; //4、稀疏数组 ==》二维数组 //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[arr2[0][0]][arr2[0][1]]; //载读取稀疏数组的后几行的数据（从第二行开始），并赋给原始的二维数组 for (int i = 1; i &lt; arr2.length; i++) &#123; chessArr2[arr2[i][0]][arr2[i][1]] = arr2[i][2]; &#125; System.out.println("还原的原始二维数组："); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; &#125;&#125; 测试： 队列 队列介绍： 队列是一个有序列表，可以用数组或是链表来实现 遵循先入先出的原则。即：先存入队列的数据先取出，后存入队列的数据后取出 示意图： 数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图。其中maxSize是该队列的最大容量 因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据的输出而改变，而rear则是随着数据的输入而改变 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 测试队列 * @author 沐雨 */public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //初始化队列 ArrayQueue queue = new ArrayQueue(5); char key = ' '; //接收用户输入 Scanner sc = new Scanner(System.in); boolean loop = true; while (loop) &#123; System.out.println("s(show)：展示队列"); System.out.println("e(exit)：退出程序"); System.out.println("a(add)：添加数据到队列"); System.out.println("g(get)：从队列取出元素"); System.out.println("h(head)：查看队列头数据"); key = sc.next().charAt(0); switch (key) &#123; case 's': queue.listQueue(); break; case 'a': System.out.println("请输入要存入的数据："); int value = sc.nextInt(); queue.addQueue(value); break; case 'g': try &#123; int res = queue.getQueue(); System.out.println("取出的数据是：" + res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int headData = queue.headQueue(); System.out.println("队列的头数据为：" + headData); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': sc.close(); loop = false; break; default: &#125; &#125; System.out.println("程序退出"); &#125;&#125;/** * 使用数组模拟队列：编写一个ArrayQueue类 */class ArrayQueue&#123; private int maxSize; //表示队列的最大容量 private int front; //队列头 private int rear; //队列尾 private int[] arr; //用于模拟队列的数组 //初始化队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; //指向队列头部，分析出front是指向队列头的前一个位置 rear = -1; //指向队列尾部，指向队列尾的数据（即队列最后一个数据） &#125; //判断队列是否满 public boolean isFull() &#123; return rear == maxSize -1; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return front == rear; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println("队列已满！"); return; &#125; rear++; //让rear后移 arr[rear] = n; &#125; //获取队列数据，即出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常来处理 throw new RuntimeException("队列为空！无数据可取"); &#125; front++; //front后移 return arr[front]; &#125; //展示队列的所有数据 public void listQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println("队列为空！"); return; &#125; for (int i = front + 1; i &lt;= rear; i++) &#123; System.out.print(arr[i] + "\t\n"); &#125; &#125; //获取队列头数据 public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空！"); &#125; return arr[front + 1]; &#125;&#125; 存在问题及优化： 数组模拟的队列只能使用一次，没有达到复用的效果 使用算法，改进成一个环形队列（采用取模的方式：%） 环形队列的思路分析： front的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，初始值为0 rear的含义做一个调整：rear指向队列最后一个元素的后一个位置，初始值为0 当队列为空时：(rear + 1) % maxSize == front 队列中有效数据的个数：(rear + maxSize - front) % maxSzie 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 测试环形队列 * @author 沐雨 */public class CircleArrayQueueDemo &#123; public static void main(String[] args) &#123; //初始化队列 CircleArrayQueue queue = new CircleArrayQueue(5); char key = ' '; //接收用户输入 Scanner sc = new Scanner(System.in); boolean loop = true; while (loop) &#123; System.out.println("s(show)：展示队列"); System.out.println("e(exit)：退出程序"); System.out.println("a(add)：添加数据到队列"); System.out.println("g(get)：从队列取出元素"); System.out.println("h(head)：查看队列头数据"); key = sc.next().charAt(0); switch (key) &#123; case 's': queue.listQueue(); break; case 'a': System.out.println("请输入要存入的数据："); int value = sc.nextInt(); queue.addQueue(value); break; case 'g': try &#123; int res = queue.getQueue(); System.out.println("取出的数据是：" + res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int headData = queue.headQueue(); System.out.println("队列的头数据为：" + headData); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': sc.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出"); &#125;&#125;/** * 环形数组队列 */class CircleArrayQueue&#123; private int maxSize; //表示队列的最大容量 private int front; //队列头，指向队列头部，指向队列第一个元素 private int rear; //队列尾，指向队列尾部，指向队列最后一个元素的后一个位置 private int[] arr; //用于模拟队列的数组 //初始化队列的构造器 public CircleArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return front == rear; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println("队列已满！"); return; &#125; //直接添加元素 arr[rear] = n; //将rear后移，这里要考虑取模 rear = (rear + 1) % maxSize; &#125; //获取队列数据，即出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常来处理 throw new RuntimeException("队列为空！无数据可取"); &#125; //把front指向的数据保存到一个临时变量 int tempValue = arr[front]; //将front后移，这里要考虑取模 front = (front + 1) % maxSize; return tempValue; &#125; //展示队列的所有数据 public void listQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println("队列为空！"); return; &#125; for (int i = front; i &lt; front + size(); i++) &#123; System.out.println(arr[i % maxSize]); &#125; &#125; //得到当前队列的大小（有效数据的个数） public int size() &#123; return (rear + maxSize - front) % maxSize; &#125; //获取队列头数据 public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空！"); &#125; return arr[front]; &#125;&#125;]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰计算器]]></title>
    <url>%2F2019%2F11%2F03%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[逆波兰计算器的实现 中缀表达式转后缀表达式 中缀表达式： 中缀表达式就是我们最常见的表达式，如：(3+4)x5-6 中缀表达式的求值时我们最熟悉的，但是对于计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其他表达式来操作（一般转为后缀表达式） 后缀表达式（逆波兰表达式） 后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后 eg：(3+4)x5-6 ==》34+5x6- 后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果 中缀表达式转后缀表达式 步骤： 初始化两个栈：运算符栈s1和存储中间结果的栈s2 从左至右扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈s1 否则，若当前运算符优先级比栈顶运算符优先级高，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入s2中，再次转到上述第1点与s1中新的栈顶运算符相比较 遇到括号时： 如果是左括号“（”，则直接压入s1 如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这对括号丢弃 重复步骤2至5，直到表达式的最右端 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 将中缀表达式字符串转为List集合 * @param expression 中缀表达式 * @return 中缀表达式对应的List集合 */public static List&lt;String&gt; toInfixList(String expression) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int index = 0; String str = ""; char ch = ' '; do &#123; ch = expression.charAt(index); //判断ch是否为数字 String s = Character.toString(ch); if (s.matches("\\d+")) &#123; //ch为数字 while (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= 48 &amp;&amp; (ch = expression.charAt(index)) &lt;= 57) &#123; s = Character.toString(ch); str += s; index++; &#125; ls.add(str); str = ""; &#125;else &#123; //ch为非数字，即为运算符或括号 ls.add(s); index++; &#125; &#125;while (index &lt; expression.length()); return ls;&#125;/** * 将中缀表达式对应的List集合转为后缀表达式的List集合 * @param list 中缀表达式对应的List集合 * @return 后缀表达式对应的List集合 */public static List&lt;String&gt; infixToSuffix(List&lt;String&gt; list) &#123; //创建一个字符栈 Stack&lt;String&gt; operStack = new Stack&lt;String&gt;(); //创建一个List List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); for (String s : list) &#123; //判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接加入到ls中 ls.add(s); &#125;else if ("(".equals(s))&#123; //s为左括号，直接入栈 operStack.push(s); &#125;else if (")".equals(s)) &#123; //s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除 while (!"(".equals(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; //消除括号 operStack.pop(); &#125;else &#123; //s为运算符 //如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级 while (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; operStack.push(s); &#125; &#125; while (!operStack.empty()) &#123; ls.add(operStack.pop()); &#125; return ls;&#125;/** * 得到运算符的优先级 * @param oper 运算符 * @return 优先级大小 */public static int priority(String oper) &#123; if ("*".equals(oper) || "/".equals(oper)) &#123; return 1; &#125;else if ("+".equals(oper) || "-".equals(oper)) &#123; return 0; &#125;else &#123; return -1; &#125;&#125; 逆波兰表达式的计算 思路分析：后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果 代码实现： 1234567891011121314151617181920212223242526272829303132333435/** * 计算逆波兰表达式的结果 * @param list 逆波兰表达式对应的List集合 * @return 逆波兰表达式的结果 */public static int calculate(List&lt;String&gt; list) &#123; //创建一个栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (String s : list) &#123; //使用正则表达式判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接入栈 stack.push(Integer.parseInt(s)); &#125;else &#123; //不是数字，为运算符 int num1 = stack.pop(); int num2 = stack.pop(); int res = 0; //判断运算符 if ("+".equals(s)) &#123; res = num2 + num1; &#125;else if ("-".equals(s)) &#123; res = num2 - num1; &#125;else if ("*".equals(s)) &#123; res = num2 * num1; &#125;else if ("/".equals(s)) &#123; res = num2 / num1; &#125; //将res入栈 stack.push(res); &#125; &#125; //最后栈中的数据就是运算的结果 return stack.pop();&#125; 完整代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 使用栈完成逆波兰表达式的计算 * @author 沐雨 */public class PolandNotation &#123; public static void main(String[] args) &#123; String infixExpression = "10+((2+3)*4)-5"; List&lt;String&gt; infixList = toInfixList(infixExpression); //System.out.println(infixList); List&lt;String&gt; suffixList = infixToSuffix(infixList); //System.out.println(suffixList); int result = calculate(suffixList); System.out.println(result); &#125; /** * 将中缀表达式字符串转为List集合 * @param expression 中缀表达式 * @return 中缀表达式对应的List集合 */ public static List&lt;String&gt; toInfixList(String expression) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int index = 0; String str = ""; char ch = ' '; do &#123; ch = expression.charAt(index); //判断ch是否为数字 String s = Character.toString(ch); if (s.matches("\\d+")) &#123; //ch为数字 while (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= 48 &amp;&amp; (ch = expression.charAt(index)) &lt;= 57) &#123; s = Character.toString(ch); str += s; index++; &#125; ls.add(str); str = ""; &#125;else &#123; //ch为非数字，即为运算符或括号 ls.add(s); index++; &#125; &#125;while (index &lt; expression.length()); return ls; &#125; /** * 将中缀表达式对应的List集合转为后缀表达式的List集合 * @param list 中缀表达式对应的List集合 * @return 后缀表达式对应的List集合 */ public static List&lt;String&gt; infixToSuffix(List&lt;String&gt; list) &#123; //创建一个字符栈 Stack&lt;String&gt; operStack = new Stack&lt;String&gt;(); //创建一个List List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); for (String s : list) &#123; //判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接加入到ls中 ls.add(s); &#125;else if ("(".equals(s))&#123; //s为左括号，直接入栈 operStack.push(s); &#125;else if (")".equals(s)) &#123; //s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除 while (!"(".equals(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; //消除括号 operStack.pop(); &#125;else &#123; //s为运算符 //如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级 while (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; operStack.push(s); &#125; &#125; while (!operStack.empty()) &#123; ls.add(operStack.pop()); &#125; return ls; &#125; /** * 得到运算符的优先级 * @param oper 运算符 * @return 优先级大小 */ public static int priority(String oper) &#123; if ("*".equals(oper) || "/".equals(oper)) &#123; return 1; &#125;else if ("+".equals(oper) || "-".equals(oper)) &#123; return 0; &#125;else &#123; return -1; &#125; &#125; /** * 计算逆波兰表达式的结果 * @param list 逆波兰表达式对应的List集合 * @return 逆波兰表达式的结果 */ public static int calculate(List&lt;String&gt; list) &#123; //创建一个栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (String s : list) &#123; //使用正则表达式判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接入栈 stack.push(Integer.parseInt(s)); &#125;else &#123; //不是数字，为运算符 int num1 = stack.pop(); int num2 = stack.pop(); int res = 0; //判断运算符 if ("+".equals(s)) &#123; res = num2 + num1; &#125;else if ("-".equals(s)) &#123; res = num2 - num1; &#125;else if ("*".equals(s)) &#123; res = num2 * num1; &#125;else if ("/".equals(s)) &#123; res = num2 / num1; &#125; //将res入栈 stack.push(res); &#125; &#125; //最后栈中的数据就是运算的结果 return stack.pop(); &#125;&#125; 代码测试：计算10+((2+3)*4)-5 结果：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端zTree插件]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%89%8D%E7%AB%AFzTree%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前端zTree插件生成树形菜单 这种树形结构菜单大家应该不会默认吧，我们在很多地方都能看到这种结构。那么如何实现这种树形结构菜单呢？今天我来教大家使用zTree来生成简单的树形结构菜单。 zTree树形结构菜单的实现 前往http://www.treejs.cn/v3/main.php#_zTreeInfo下载zTree插件。 点击下载，前往码云下载zTree插件（未注册码云的需要注册登录才能下载） 下载完成后将其解压。相关文件内容如下 创建一个Java工程，将zTree所需要的css和js文件复制到web目录下。 创建HTML页面，引入相关css和js。 1234&lt;link rel=&quot;stylesheet&quot; href=&quot;./zTree/css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.core.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.excheck.js&quot;&gt;&lt;/script&gt; 引入js文件时根据自己所需要的树形结构进行引入，可到zTree文件夹下的demo中查看，寻找自己想要的树形结构。我这里选择的是带复选框的树形结构。 设置树形菜单。 12345678910var setting = &#123; check: &#123; enable: true &#125;, data: &#123; simpleData: &#123; enable: true &#125; &#125;&#125;; 采用json数据格式来设置树形菜单。 给树形菜单提供数据。 123456789101112131415var zNodes =[ &#123; id:1, pId:0, name:&quot;随意勾选 1&quot;, open:true&#125;, &#123; id:11, pId:1, name:&quot;随意勾选 1-1&quot;, open:true&#125;, &#123; id:111, pId:11, name:&quot;随意勾选 1-1-1&quot;&#125;, &#123; id:112, pId:11, name:&quot;随意勾选 1-1-2&quot;&#125;, &#123; id:12, pId:1, name:&quot;随意勾选 1-2&quot;, open:true&#125;, &#123; id:121, pId:12, name:&quot;随意勾选 1-2-1&quot;&#125;, &#123; id:122, pId:12, name:&quot;随意勾选 1-2-2&quot;&#125;, &#123; id:2, pId:0, name:&quot;随意勾选 2&quot;, checked:true, open:true&#125;, &#123; id:21, pId:2, name:&quot;随意勾选 2-1&quot;&#125;, &#123; id:22, pId:2, name:&quot;随意勾选 2-2&quot;, open:true&#125;, &#123; id:221, pId:22, name:&quot;随意勾选 2-2-1&quot;, checked:true&#125;, &#123; id:222, pId:22, name:&quot;随意勾选 2-2-2&quot;&#125;, &#123; id:23, pId:2, name:&quot;随意勾选 2-3&quot;&#125;]; 生成属性结构菜单。 定义生成树的容器。为固定的HTML代码。 12&lt;!-- 容器，将树生成在这个容器上，固定代码 --&gt;&lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; 生成树。 123456789//生成树，固定的代码$(document).ready(function()&#123; /**init方法的参数： * 1、容器 * 2、设置 * 3、节点数据 */ zTreeObj = $.fn.zTree.init($(&quot;#tree&quot;), setting, zNodes);&#125;); 这样，我们的树形结构菜单就生成了。 注意事项： 注意jquery的js文件引入时应在第一个标签。 使用IDEA这种开发工具访问页面时要开启tomcat来访问。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>zTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery validate插件的使用]]></title>
    <url>%2F2019%2F09%2F26%2Fjquery-validate%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jQuery Validate插件做JavaWeb项目时的登录注册页面等，少不了的就是我们的表单数据的验证。而传统我们可以使用ajax、JSR 303等方法来验证表单数据，而这些都是由后台人员来编写的。今天，我来给大家介绍一个前端人员也可以做出表单数据验证方法，那就是我们的JQuery Validate插件，它提供了强大的验证功能，操作也相对简单。 导入js库 可以选择前往https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1下载插件 也可以选择直接导入在线CDN： https://cdn.jsdelivr.net/npm/jquery-validation@1.19.1/dist/jquery.validate.min.js 默认校验规则 默认提示 123456789101112131415161718messages: &#123; required: "This field is required.", remote: "Please fix this field.", email: "Please enter a valid email address.", url: "Please enter a valid URL.", date: "Please enter a valid date.", dateISO: "Please enter a valid date ( ISO ).", number: "Please enter a valid number.", digits: "Please enter only digits.", creditcard: "Please enter a valid credit card number.", equalTo: "Please enter the same value again.", maxlength: $.validator.format( "Please enter no more than &#123;0&#125; characters." ）， minlength: $.validator.format( "Please enter at least &#123;0&#125; characters." ), rangelength: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125; characters long." ), range: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125;." ), max: $.validator.format( "Please enter a value less than or equal to &#123;0&#125;." ), min: $.validator.format( "Please enter a value greater than or equal to &#123;0&#125;." )&#125; jQuery Validate提供了中文信息提示包，位于下载包的 dist/localization/messages_zh.js，可选择将其引入到页面中，也可以选择在线CDN，这里就不再描述了 使用方式 将校验规则写到控件中 1234567891011121314151617181920212223242526272829303132333435&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $().ready(function() &#123; $(&quot;#commentForm&quot;).validate(); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;cmxform&quot; id=&quot;commentForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;输入您的信息&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;cname&quot;&gt;Name (必需, 最小两个字母)&lt;/label&gt; &lt;input id=&quot;cname&quot; name=&quot;username&quot; minlength=&quot;2&quot; type=&quot;text&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;cemail&quot;&gt;E-Mail (必需)&lt;/label&gt; &lt;input id=&quot;cemail&quot; type=&quot;email&quot; name=&quot;email&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;ccomment&quot;&gt;电话 (必需)&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;ccomment&quot; name=&quot;phone&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在键盘按下并释放及提交后验证提交表单，同时当表单失去焦点时也会进行验证 将校验规则写到js代码中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.validator.setDefaults(&#123; submitHandler: function() &#123; alert(&quot;提交事件!&quot;); &#125;&#125;);$().ready(function() &#123;// 在键盘按下并释放及提交后验证提交表单 $(&quot;#signupForm&quot;).validate(&#123; rules: &#123; firstname: &quot;required&quot;, lastname: &quot;required&quot;, username: &#123; required: true, minlength: 2 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: &quot;#password&quot; &#125;, email: &#123; required: true, email: true &#125; &#125;, messages: &#123; firstname: &quot;请输入您的名字&quot;, lastname: &quot;请输入您的姓氏&quot;, username: &#123; required: &quot;请输入用户名&quot;, minlength: &quot;用户名必需由两个字母组成&quot; &#125;, password: &#123; required: &quot;请输入密码&quot;, minlength: &quot;密码长度不能小于 5 个字母&quot; &#125;, confirm_password: &#123; required: &quot;请输入密码&quot;, minlength: &quot;密码长度不能小于 5 个字母&quot;, equalTo: &quot;两次密码输入不一致&quot; &#125;, email: &quot;请输入一个正确的邮箱&quot; &#125; &#125;);&#125;);&lt;/script&gt;&lt;style&gt;.error&#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;cmxform&quot; id=&quot;signupForm&quot; method=&quot;get&quot; action=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;验证完整的表单&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;firstname&quot;&gt;名字&lt;/label&gt; &lt;input id=&quot;firstname&quot; name=&quot;firstname&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;lastname&quot;&gt;姓氏&lt;/label&gt; &lt;input id=&quot;lastname&quot; name=&quot;lastname&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;验证密码&lt;/label&gt; &lt;input id=&quot;confirm_password&quot; name=&quot;confirm_password&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; required：true 值是必须的。 required：”#aa:checked”表达式的值为真，则需要验证。 required：function(){}返回为真，表示需要验证。 后面两种常用于表单中需要同时填或不填的元素。 还有其他常用方法及一些注意事项就不一一说明了，详情可前往：https://www.runoob.com/jquery/jquery-plugin-validate.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jquery validate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备工作 前往https://nodejs.org/en/ 下载安装node.js 可在cmd输入node -v查看是否安装成功，若出现版本信息则安装成功 前往https://git-scm.com/download/win 下载安装Git 可在cmd中输入git –version查看版本信息判断是否安装成功 github账户注册配置 利用npm安装淘宝npm（cnpm）：npm install -g cnpm –registry=https://registry.npm.taobao.org 可在cmd输入cnpm -v查看版本信息判断是否安装成功 安装淘宝npm是因为使用npm可能会很慢 安装hexo：cnpm install -g hexo-cli 可在cmd输入hexo -v验证是否安装成功 搭建博客 找个位置建立一个博客的总文件夹。例如我在E盘下建立了一个myblog文件夹 如果在搭建博客的过程中有问题，大不了把文件夹删除重新再来，无需畏惧 管理员打开cmd（在博客文件夹鼠标右键使用Git Bash也可以）输入hexo init 生成博客相关文件相关内容，后续对博客进行修改对相关内容进行修改即可 切到博客文件根目录输入hexo s 在本地的localhost:4000启动博客 我这是已搭建好的博客，主题和初次搭建不一样 创建一篇博客文章：hexo new ‘博客文章名称’ 会在博客文件夹下的source下的_posts目录下生成一篇博客文章（Markdown格式） 博客文章内容自己编写即可 再次生成博客： hexo clean （清理一下） hexo g （重新生成） hexo s （在本地访问预览） 将博客部署到github上 登录GitHub，新建仓库 注意仓库名称：github账户昵称.github.io 我这里报错是因为我已经建立了博客仓库 安装git部署插件：cnpm install –save hexo-deployer-git 安装好git部署插件后，在博客根目录找到全局配置文件 设置_config.yml文件，使用notepad++（最好不要使用记事本打开）打开，找到deploy，设置type为git，添加github博客仓库地址repo以及branch 注：冒号后面有一个空格 命令行输入hexo d部署到github 这样就将博客部署到github上去了，以后就可以通过访问博客仓库名直接访问到我们的博客了 博客文章引入图片问题 本地引入图片路径问题： 如果在未下载引入图片相关插件时，图片路径会乱码，导致在博客文章中无法显示图片 解决： 安装引入图片插件： cnpm install https://github.com/CodeFalling/hexo-asset-image –save 打开全局_config.yml将post_asset_folder: false改为post_asset_folder: true 运行hexo new ‘xxx’后会在posts目录下同时生成一个与博客文章同名的文件夹，将图片放在该文件夹里（直接放在文件夹内，不需要在里面再建文件夹放置） 在博客文章中想添加图片的位置写入： 1![](/图片名称.图片格式) //如![](/image.png) 5. 在博客根目录打开cmd输入hexo g和hexo s在本地预览查看]]></content>
      <categories>
        <category>hexo博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
