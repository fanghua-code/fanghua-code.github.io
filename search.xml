<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[稀疏数组和队列]]></title>
    <url>%2F2019%2F11%2F03%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[稀疏数组和队列 稀疏数组：当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组 处理方法： 记录数组一共几行几列，有多少个不为0的元素 把 不为0的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 应用实例： 使用稀疏数组来保留非0元素较多的二维数组（棋盘、地图等等） 把稀疏数组存盘，并且可以重新恢复为原来的二维数组 分析： 二维数组 ==》稀疏数组 遍历原始的二维数组，得到有效数据（非0元素）的个数sum 根据sum就可以创建稀疏数组sparseArr int[sum+1][3] 将二维数组的有效数据存入到稀疏数组 稀疏数组 ==》二维数组 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 再读取稀疏数组后几行的数据，并赋给原始二维数组即可 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/** * 二维数组与稀疏数组的转换（这里以棋盘的存档与读档为例） * @author 沐雨 */public class SparseArrDemo &#123; public static void main(String[] args) &#123; //0、先创建原始的11x11的二维数组，0表示没有棋子，1表示黑子，2表示白子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; //棋盘第二行第三列有一颗黑子 chessArr1[2][3] = 2; //棋盘第三行第四列有一颗白子 //遍历原始数组 for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; //1、二维数组 ==》稀疏数组 //遍历原始二维数组，获取非0元素个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; //创建稀疏数组 int sparseArr[][] = new int[sum + 1][3]; //给稀疏数组第一行赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; int count = 0; //用于记录第几个非0数据 //遍历原始数组，将非0元素添加到稀疏数组中 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; //输出稀疏数组的形式 System.out.println("得到的稀疏数组的形式："); for (int[] row : sparseArr) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; System.out.println("-----------------------------------------"); //2、稀疏数组 ==》文件 OutputStream out = null; PrintStream ps = null; try &#123; out = new FileOutputStream("map.txt"); ps = new PrintStream(out); for (int i = 0; i &lt; sparseArr.length; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; ps.print(sparseArr[i][j] + ","); &#125; ps.println(); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; ps.close(); try &#123; out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //3、文件 ==》稀疏数组 String arr1[] = new String[sum + 1]; int arr2[][] = new int[sum + 1][3]; BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader("map.txt")); String line = null; int i = 0; while ((line = reader.readLine()) != null) &#123; arr1[i] = line; i++; &#125; for (int j = 0; j &lt; sum + 1; j++) &#123; String[] split = arr1[j].split(","); for (int k = 0; k &lt; split.length; k++) &#123; arr2[j][k] = Integer.parseInt(split[k]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; for (int[] row : arr2) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; //4、稀疏数组 ==》二维数组 //先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[arr2[0][0]][arr2[0][1]]; //载读取稀疏数组的后几行的数据（从第二行开始），并赋给原始的二维数组 for (int i = 1; i &lt; arr2.length; i++) &#123; chessArr2[arr2[i][0]][arr2[i][1]] = arr2[i][2]; &#125; System.out.println("还原的原始二维数组："); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.print(data + "\t"); &#125; System.out.println(); &#125; &#125;&#125; 测试： 队列 队列介绍： 队列是一个有序列表，可以用数组或是链表来实现 遵循先入先出的原则。即：先存入队列的数据先取出，后存入队列的数据后取出 示意图： 数组模拟队列 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如上图。其中maxSize是该队列的最大容量 因为队列的输入、输出是分别从前后端来处理，因此需要两个变量front和rear分别记录队列前后端的下标，front会随着数据的输出而改变，而rear则是随着数据的输入而改变 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * 测试队列 * @author 沐雨 */public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //初始化队列 ArrayQueue queue = new ArrayQueue(5); char key = ' '; //接收用户输入 Scanner sc = new Scanner(System.in); boolean loop = true; while (loop) &#123; System.out.println("s(show)：展示队列"); System.out.println("e(exit)：退出程序"); System.out.println("a(add)：添加数据到队列"); System.out.println("g(get)：从队列取出元素"); System.out.println("h(head)：查看队列头数据"); key = sc.next().charAt(0); switch (key) &#123; case 's': queue.listQueue(); break; case 'a': System.out.println("请输入要存入的数据："); int value = sc.nextInt(); queue.addQueue(value); break; case 'g': try &#123; int res = queue.getQueue(); System.out.println("取出的数据是：" + res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int headData = queue.headQueue(); System.out.println("队列的头数据为：" + headData); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': sc.close(); loop = false; break; default: &#125; &#125; System.out.println("程序退出"); &#125;&#125;/** * 使用数组模拟队列：编写一个ArrayQueue类 */class ArrayQueue&#123; private int maxSize; //表示队列的最大容量 private int front; //队列头 private int rear; //队列尾 private int[] arr; //用于模拟队列的数组 //初始化队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; //指向队列头部，分析出front是指向队列头的前一个位置 rear = -1; //指向队列尾部，指向队列尾的数据（即队列最后一个数据） &#125; //判断队列是否满 public boolean isFull() &#123; return rear == maxSize -1; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return front == rear; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println("队列已满！"); return; &#125; rear++; //让rear后移 arr[rear] = n; &#125; //获取队列数据，即出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常来处理 throw new RuntimeException("队列为空！无数据可取"); &#125; front++; //front后移 return arr[front]; &#125; //展示队列的所有数据 public void listQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println("队列为空！"); return; &#125; for (int i = front + 1; i &lt;= rear; i++) &#123; System.out.print(arr[i] + "\t\n"); &#125; &#125; //获取队列头数据 public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空！"); &#125; return arr[front + 1]; &#125;&#125; 存在问题及优化： 数组模拟的队列只能使用一次，没有达到复用的效果 使用算法，改进成一个环形队列（采用取模的方式：%） 环形队列的思路分析： front的含义做一个调整：front指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素，初始值为0 rear的含义做一个调整：rear指向队列最后一个元素的后一个位置，初始值为0 当队列为空时：(rear + 1) % maxSize == front 队列中有效数据的个数：(rear + maxSize - front) % maxSzie 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 测试环形队列 * @author 沐雨 */public class CircleArrayQueueDemo &#123; public static void main(String[] args) &#123; //初始化队列 CircleArrayQueue queue = new CircleArrayQueue(5); char key = ' '; //接收用户输入 Scanner sc = new Scanner(System.in); boolean loop = true; while (loop) &#123; System.out.println("s(show)：展示队列"); System.out.println("e(exit)：退出程序"); System.out.println("a(add)：添加数据到队列"); System.out.println("g(get)：从队列取出元素"); System.out.println("h(head)：查看队列头数据"); key = sc.next().charAt(0); switch (key) &#123; case 's': queue.listQueue(); break; case 'a': System.out.println("请输入要存入的数据："); int value = sc.nextInt(); queue.addQueue(value); break; case 'g': try &#123; int res = queue.getQueue(); System.out.println("取出的数据是：" + res); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'h': try &#123; int headData = queue.headQueue(); System.out.println("队列的头数据为：" + headData); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; break; case 'e': sc.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出"); &#125;&#125;/** * 环形数组队列 */class CircleArrayQueue&#123; private int maxSize; //表示队列的最大容量 private int front; //队列头，指向队列头部，指向队列第一个元素 private int rear; //队列尾，指向队列尾部，指向队列最后一个元素的后一个位置 private int[] arr; //用于模拟队列的数组 //初始化队列的构造器 public CircleArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; //判断队列是否满 public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; //判断队列是否为空 public boolean isEmpty() &#123; return front == rear; &#125; //添加数据到队列 public void addQueue(int n) &#123; //判断队列是否满 if (isFull()) &#123; System.out.println("队列已满！"); return; &#125; //直接添加元素 arr[rear] = n; //将rear后移，这里要考虑取模 rear = (rear + 1) % maxSize; &#125; //获取队列数据，即出队列 public int getQueue() &#123; //判断队列是否为空 if (isEmpty()) &#123; //通过抛出异常来处理 throw new RuntimeException("队列为空！无数据可取"); &#125; //把front指向的数据保存到一个临时变量 int tempValue = arr[front]; //将front后移，这里要考虑取模 front = (front + 1) % maxSize; return tempValue; &#125; //展示队列的所有数据 public void listQueue() &#123; //遍历 if (isEmpty()) &#123; System.out.println("队列为空！"); return; &#125; for (int i = front; i &lt; front + size(); i++) &#123; System.out.println(arr[i % maxSize]); &#125; &#125; //得到当前队列的大小（有效数据的个数） public int size() &#123; return (rear + maxSize - front) % maxSize; &#125; //获取队列头数据 public int headQueue() &#123; if (isEmpty()) &#123; throw new RuntimeException("队列为空！"); &#125; return arr[front]; &#125;&#125;]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰计算器]]></title>
    <url>%2F2019%2F11%2F03%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[逆波兰计算器的实现 中缀表达式转后缀表达式 中缀表达式： 中缀表达式就是我们最常见的表达式，如：(3+4)x5-6 中缀表达式的求值时我们最熟悉的，但是对于计算机来说却不好操作，因此，在计算结果时，往往会将中缀表达式转成其他表达式来操作（一般转为后缀表达式） 后缀表达式（逆波兰表达式） 后缀表达式又称为逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后 eg：(3+4)x5-6 ==》34+5x6- 后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果 中缀表达式转后缀表达式 步骤： 初始化两个栈：运算符栈s1和存储中间结果的栈s2 从左至右扫描中缀表达式 遇到操作数时，将其压入s2 遇到运算符时，比较其与s1栈顶运算符的优先级： 如果s1为空，或栈顶运算符为左括号“（”，则直接将此运算符入栈s1 否则，若当前运算符优先级比栈顶运算符优先级高，也将运算符压入s1 否则，将s1栈顶的运算符弹出并压入s2中，再次转到上述第1点与s1中新的栈顶运算符相比较 遇到括号时： 如果是左括号“（”，则直接压入s1 如果是右括号“）”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这对括号丢弃 重复步骤2至5，直到表达式的最右端 将s1中剩余的运算符依次弹出并压入s2 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 将中缀表达式字符串转为List集合 * @param expression 中缀表达式 * @return 中缀表达式对应的List集合 */public static List&lt;String&gt; toInfixList(String expression) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int index = 0; String str = ""; char ch = ' '; do &#123; ch = expression.charAt(index); //判断ch是否为数字 String s = Character.toString(ch); if (s.matches("\\d+")) &#123; //ch为数字 while (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= 48 &amp;&amp; (ch = expression.charAt(index)) &lt;= 57) &#123; s = Character.toString(ch); str += s; index++; &#125; ls.add(str); str = ""; &#125;else &#123; //ch为非数字，即为运算符或括号 ls.add(s); index++; &#125; &#125;while (index &lt; expression.length()); return ls;&#125;/** * 将中缀表达式对应的List集合转为后缀表达式的List集合 * @param list 中缀表达式对应的List集合 * @return 后缀表达式对应的List集合 */public static List&lt;String&gt; infixToSuffix(List&lt;String&gt; list) &#123; //创建一个字符栈 Stack&lt;String&gt; operStack = new Stack&lt;String&gt;(); //创建一个List List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); for (String s : list) &#123; //判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接加入到ls中 ls.add(s); &#125;else if ("(".equals(s))&#123; //s为左括号，直接入栈 operStack.push(s); &#125;else if (")".equals(s)) &#123; //s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除 while (!"(".equals(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; //消除括号 operStack.pop(); &#125;else &#123; //s为运算符 //如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级 while (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; operStack.push(s); &#125; &#125; while (!operStack.empty()) &#123; ls.add(operStack.pop()); &#125; return ls;&#125;/** * 得到运算符的优先级 * @param oper 运算符 * @return 优先级大小 */public static int priority(String oper) &#123; if ("*".equals(oper) || "/".equals(oper)) &#123; return 1; &#125;else if ("+".equals(oper) || "-".equals(oper)) &#123; return 0; &#125;else &#123; return -1; &#125;&#125; 逆波兰表达式的计算 思路分析：后缀表达式的计算机求值：从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符进行相应的计算，并将结果入栈；重复上述过程直到表达式的最右端，最后运算得出的值即为表达式的结果 代码实现： 1234567891011121314151617181920212223242526272829303132333435/** * 计算逆波兰表达式的结果 * @param list 逆波兰表达式对应的List集合 * @return 逆波兰表达式的结果 */public static int calculate(List&lt;String&gt; list) &#123; //创建一个栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (String s : list) &#123; //使用正则表达式判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接入栈 stack.push(Integer.parseInt(s)); &#125;else &#123; //不是数字，为运算符 int num1 = stack.pop(); int num2 = stack.pop(); int res = 0; //判断运算符 if ("+".equals(s)) &#123; res = num2 + num1; &#125;else if ("-".equals(s)) &#123; res = num2 - num1; &#125;else if ("*".equals(s)) &#123; res = num2 * num1; &#125;else if ("/".equals(s)) &#123; res = num2 / num1; &#125; //将res入栈 stack.push(res); &#125; &#125; //最后栈中的数据就是运算的结果 return stack.pop();&#125; 完整代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** * 使用栈完成逆波兰表达式的计算 * @author 沐雨 */public class PolandNotation &#123; public static void main(String[] args) &#123; String infixExpression = "10+((2+3)*4)-5"; List&lt;String&gt; infixList = toInfixList(infixExpression); //System.out.println(infixList); List&lt;String&gt; suffixList = infixToSuffix(infixList); //System.out.println(suffixList); int result = calculate(suffixList); System.out.println(result); &#125; /** * 将中缀表达式字符串转为List集合 * @param expression 中缀表达式 * @return 中缀表达式对应的List集合 */ public static List&lt;String&gt; toInfixList(String expression) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int index = 0; String str = ""; char ch = ' '; do &#123; ch = expression.charAt(index); //判断ch是否为数字 String s = Character.toString(ch); if (s.matches("\\d+")) &#123; //ch为数字 while (index &lt; expression.length() &amp;&amp; (ch = expression.charAt(index)) &gt;= 48 &amp;&amp; (ch = expression.charAt(index)) &lt;= 57) &#123; s = Character.toString(ch); str += s; index++; &#125; ls.add(str); str = ""; &#125;else &#123; //ch为非数字，即为运算符或括号 ls.add(s); index++; &#125; &#125;while (index &lt; expression.length()); return ls; &#125; /** * 将中缀表达式对应的List集合转为后缀表达式的List集合 * @param list 中缀表达式对应的List集合 * @return 后缀表达式对应的List集合 */ public static List&lt;String&gt; infixToSuffix(List&lt;String&gt; list) &#123; //创建一个字符栈 Stack&lt;String&gt; operStack = new Stack&lt;String&gt;(); //创建一个List List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); for (String s : list) &#123; //判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接加入到ls中 ls.add(s); &#125;else if ("(".equals(s))&#123; //s为左括号，直接入栈 operStack.push(s); &#125;else if (")".equals(s)) &#123; //s为右括号，将字符栈中的元素加入到结果集合ls中，知道遇到左括号"("，将括号消除 while (!"(".equals(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; //消除括号 operStack.pop(); &#125;else &#123; //s为运算符 //如果当前运算符优先级小于栈顶的运算符有限，则将栈顶运算符加入到结果集合中，再判断和栈顶运算符的优先级 while (!operStack.empty() &amp;&amp; priority(s) &lt;= priority(operStack.peek())) &#123; ls.add(operStack.pop()); &#125; operStack.push(s); &#125; &#125; while (!operStack.empty()) &#123; ls.add(operStack.pop()); &#125; return ls; &#125; /** * 得到运算符的优先级 * @param oper 运算符 * @return 优先级大小 */ public static int priority(String oper) &#123; if ("*".equals(oper) || "/".equals(oper)) &#123; return 1; &#125;else if ("+".equals(oper) || "-".equals(oper)) &#123; return 0; &#125;else &#123; return -1; &#125; &#125; /** * 计算逆波兰表达式的结果 * @param list 逆波兰表达式对应的List集合 * @return 逆波兰表达式的结果 */ public static int calculate(List&lt;String&gt; list) &#123; //创建一个栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for (String s : list) &#123; //使用正则表达式判断s是否为数字 if (s.matches("\\d+")) &#123; //s为数字，直接入栈 stack.push(Integer.parseInt(s)); &#125;else &#123; //不是数字，为运算符 int num1 = stack.pop(); int num2 = stack.pop(); int res = 0; //判断运算符 if ("+".equals(s)) &#123; res = num2 + num1; &#125;else if ("-".equals(s)) &#123; res = num2 - num1; &#125;else if ("*".equals(s)) &#123; res = num2 * num1; &#125;else if ("/".equals(s)) &#123; res = num2 / num1; &#125; //将res入栈 stack.push(res); &#125; &#125; //最后栈中的数据就是运算的结果 return stack.pop(); &#125;&#125; 代码测试：计算10+((2+3)*4)-5 结果：]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>java数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端zTree插件]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%89%8D%E7%AB%AFzTree%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前端zTree插件生成树形菜单 这种树形结构菜单大家应该不会默认吧，我们在很多地方都能看到这种结构。那么如何实现这种树形结构菜单呢？今天我来教大家使用zTree来生成简单的树形结构菜单。 zTree树形结构菜单的实现 前往http://www.treejs.cn/v3/main.php#_zTreeInfo下载zTree插件。 点击下载，前往码云下载zTree插件（未注册码云的需要注册登录才能下载） 下载完成后将其解压。相关文件内容如下 创建一个Java工程，将zTree所需要的css和js文件复制到web目录下。 创建HTML页面，引入相关css和js。 1234&lt;link rel=&quot;stylesheet&quot; href=&quot;./zTree/css/zTreeStyle/zTreeStyle.css&quot; type=&quot;text/css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery-1.4.4.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.core.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;./zTree/js/jquery.ztree.excheck.js&quot;&gt;&lt;/script&gt; 引入js文件时根据自己所需要的树形结构进行引入，可到zTree文件夹下的demo中查看，寻找自己想要的树形结构。我这里选择的是带复选框的树形结构。 设置树形菜单。 12345678910var setting = &#123; check: &#123; enable: true &#125;, data: &#123; simpleData: &#123; enable: true &#125; &#125;&#125;; 采用json数据格式来设置树形菜单。 给树形菜单提供数据。 123456789101112131415var zNodes =[ &#123; id:1, pId:0, name:&quot;随意勾选 1&quot;, open:true&#125;, &#123; id:11, pId:1, name:&quot;随意勾选 1-1&quot;, open:true&#125;, &#123; id:111, pId:11, name:&quot;随意勾选 1-1-1&quot;&#125;, &#123; id:112, pId:11, name:&quot;随意勾选 1-1-2&quot;&#125;, &#123; id:12, pId:1, name:&quot;随意勾选 1-2&quot;, open:true&#125;, &#123; id:121, pId:12, name:&quot;随意勾选 1-2-1&quot;&#125;, &#123; id:122, pId:12, name:&quot;随意勾选 1-2-2&quot;&#125;, &#123; id:2, pId:0, name:&quot;随意勾选 2&quot;, checked:true, open:true&#125;, &#123; id:21, pId:2, name:&quot;随意勾选 2-1&quot;&#125;, &#123; id:22, pId:2, name:&quot;随意勾选 2-2&quot;, open:true&#125;, &#123; id:221, pId:22, name:&quot;随意勾选 2-2-1&quot;, checked:true&#125;, &#123; id:222, pId:22, name:&quot;随意勾选 2-2-2&quot;&#125;, &#123; id:23, pId:2, name:&quot;随意勾选 2-3&quot;&#125;]; 生成属性结构菜单。 定义生成树的容器。为固定的HTML代码。 12&lt;!-- 容器，将树生成在这个容器上，固定代码 --&gt;&lt;ul id=&quot;tree&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; 生成树。 123456789//生成树，固定的代码$(document).ready(function()&#123; /**init方法的参数： * 1、容器 * 2、设置 * 3、节点数据 */ zTreeObj = $.fn.zTree.init($(&quot;#tree&quot;), setting, zNodes);&#125;); 这样，我们的树形结构菜单就生成了。 注意事项： 注意jquery的js文件引入时应在第一个标签。 使用IDEA这种开发工具访问页面时要开启tomcat来访问。]]></content>
      <tags>
        <tag>zTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery validate插件的使用]]></title>
    <url>%2F2019%2F09%2F26%2Fjquery-validate%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jQuery Validate插件做JavaWeb项目时的登录注册页面等，少不了的就是我们的表单数据的验证。而传统我们可以使用ajax、JSR 303等方法来验证表单数据，而这些都是由后台人员来编写的。今天，我来给大家介绍一个前端人员也可以做出表单数据验证方法，那就是我们的JQuery Validate插件，它提供了强大的验证功能，操作也相对简单。 导入js库 可以选择前往https://github.com/jquery-validation/jquery-validation/releases/tag/1.19.1下载插件 也可以选择直接导入在线CDN： https://cdn.jsdelivr.net/npm/jquery-validation@1.19.1/dist/jquery.validate.min.js 默认校验规则 默认提示 123456789101112131415161718messages: &#123; required: "This field is required.", remote: "Please fix this field.", email: "Please enter a valid email address.", url: "Please enter a valid URL.", date: "Please enter a valid date.", dateISO: "Please enter a valid date ( ISO ).", number: "Please enter a valid number.", digits: "Please enter only digits.", creditcard: "Please enter a valid credit card number.", equalTo: "Please enter the same value again.", maxlength: $.validator.format( "Please enter no more than &#123;0&#125; characters." ）， minlength: $.validator.format( "Please enter at least &#123;0&#125; characters." ), rangelength: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125; characters long." ), range: $.validator.format( "Please enter a value between &#123;0&#125; and &#123;1&#125;." ), max: $.validator.format( "Please enter a value less than or equal to &#123;0&#125;." ), min: $.validator.format( "Please enter a value greater than or equal to &#123;0&#125;." )&#125; jQuery Validate提供了中文信息提示包，位于下载包的 dist/localization/messages_zh.js，可选择将其引入到页面中，也可以选择在线CDN，这里就不再描述了 使用方式 将校验规则写到控件中 1234567891011121314151617181920212223242526272829303132333435&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $().ready(function() &#123; $(&quot;#commentForm&quot;).validate(); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;cmxform&quot; id=&quot;commentForm&quot; method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/test&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;输入您的信息&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;cname&quot;&gt;Name (必需, 最小两个字母)&lt;/label&gt; &lt;input id=&quot;cname&quot; name=&quot;username&quot; minlength=&quot;2&quot; type=&quot;text&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;cemail&quot;&gt;E-Mail (必需)&lt;/label&gt; &lt;input id=&quot;cemail&quot; type=&quot;email&quot; name=&quot;email&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;ccomment&quot;&gt;电话 (必需)&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;ccomment&quot; name=&quot;phone&quot; required&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在键盘按下并释放及提交后验证提交表单，同时当表单失去焦点时也会进行验证 将校验规则写到js代码中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://static.runoob.com/assets/jquery-validation-1.14.0/dist/localization/messages_zh.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.validator.setDefaults(&#123; submitHandler: function() &#123; alert(&quot;提交事件!&quot;); &#125;&#125;);$().ready(function() &#123;// 在键盘按下并释放及提交后验证提交表单 $(&quot;#signupForm&quot;).validate(&#123; rules: &#123; firstname: &quot;required&quot;, lastname: &quot;required&quot;, username: &#123; required: true, minlength: 2 &#125;, password: &#123; required: true, minlength: 5 &#125;, confirm_password: &#123; required: true, minlength: 5, equalTo: &quot;#password&quot; &#125;, email: &#123; required: true, email: true &#125; &#125;, messages: &#123; firstname: &quot;请输入您的名字&quot;, lastname: &quot;请输入您的姓氏&quot;, username: &#123; required: &quot;请输入用户名&quot;, minlength: &quot;用户名必需由两个字母组成&quot; &#125;, password: &#123; required: &quot;请输入密码&quot;, minlength: &quot;密码长度不能小于 5 个字母&quot; &#125;, confirm_password: &#123; required: &quot;请输入密码&quot;, minlength: &quot;密码长度不能小于 5 个字母&quot;, equalTo: &quot;两次密码输入不一致&quot; &#125;, email: &quot;请输入一个正确的邮箱&quot; &#125; &#125;);&#125;);&lt;/script&gt;&lt;style&gt;.error&#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form class=&quot;cmxform&quot; id=&quot;signupForm&quot; method=&quot;get&quot; action=&quot;&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;验证完整的表单&lt;/legend&gt; &lt;p&gt; &lt;label for=&quot;firstname&quot;&gt;名字&lt;/label&gt; &lt;input id=&quot;firstname&quot; name=&quot;firstname&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;lastname&quot;&gt;姓氏&lt;/label&gt; &lt;input id=&quot;lastname&quot; name=&quot;lastname&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input id=&quot;username&quot; name=&quot;username&quot; type=&quot;text&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;input id=&quot;password&quot; name=&quot;password&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;confirm_password&quot;&gt;验证密码&lt;/label&gt; &lt;input id=&quot;confirm_password&quot; name=&quot;confirm_password&quot; type=&quot;password&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot;&gt; &lt;/p&gt; &lt;p&gt; &lt;input class=&quot;submit&quot; type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/p&gt; &lt;/fieldset&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; required：true 值是必须的。 required：”#aa:checked”表达式的值为真，则需要验证。 required：function(){}返回为真，表示需要验证。 后面两种常用于表单中需要同时填或不填的元素。 还有其他常用方法及一些注意事项就不一一说明了，详情可前往：https://www.runoob.com/jquery/jquery-plugin-validate.html]]></content>
      <tags>
        <tag>jquery validate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建博客]]></title>
    <url>%2F2019%2F09%2F19%2Fhexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[准备工作 前往https://nodejs.org/en/下载安装node.js 可在cmd输入node -v查看是否安装成功，若出现版本信息则安装成功 前往https://git-scm.com/download/win下载安装Git 可在cmd中输入git –version查看版本信息判断是否安装成功 github账户注册配置 利用npm安装淘宝npm（cnpm）：npm install -g cnpm –registry=https://registry.npm.taobao.org 可在cmd输入cnpm -v查看版本信息判断是否安装成功 安装淘宝npm是因为使用npm可能会很慢 安装hexo：cnpm install -g hexo-cli 可在cmd输入hexo -v验证是否安装成功 搭建博客 找个位置建立一个博客的总文件夹。例如我在E盘下建立了一个myblog文件夹 如果在搭建博客的过程中有问题，大不了把文件夹删除重新再来，无需畏惧 管理员打开cmd（在博客文件夹鼠标右键使用Git Bash也可以）输入hexo init 生成博客相关文件相关内容，后续对博客进行修改对相关内容进行修改即可 切到博客文件根目录输入hexo s 在本地的localhost:4000启动博客 我这是已搭建好的博客，主题和初次搭建不一样 创建一篇博客文章：hexo new ‘博客文章名称’ 会在博客文件夹下的source下的_posts目录下生成一篇博客文章（Markdown格式） 博客文章内容自己编写即可 再次生成博客： hexo clean （清理一下） hexo g （重新生成） hexo s （在本地访问预览） 将博客部署到github上 登录GitHub，新建仓库 注意仓库名称：github账户昵称.github.io 我这里报错是因为我已经建立了博客仓库 安装git部署插件：cnpm install –save hexo-deployer-git 安装好git部署插件后，在博客根目录找到全局配置文件 设置_config.yml文件，使用notepad++（最好不要使用记事本打开）打开，找到deploy，设置type为git，添加github博客仓库地址repo以及branch 注：冒号后面有一个空格 命令行输入hexo d部署到github 这样就将博客部署到github上去了，以后就可以通过访问博客仓库名直接访问到我们的博客了 博客文章引入图片问题 本地引入图片路径问题： 如果在未下载引入图片相关插件时，图片路径会乱码，导致在博客文章中无法显示图片 解决： 安装引入图片插件：cnpm install https://github.com/CodeFalling/hexo-asset-image –save 打开全局_config.yml将post_asset_folder: false改为post_asset_folder: true 运行hexo new ‘xxx’后会在posts目录下同时生成一个与博客文章同名的文件夹，将图片放在该文件夹里（直接放在文件夹内，不需要在里面再建文件夹放置） 在博客文章中想添加图片的位置写入： 1![](/图片名称.图片格式) //如![](/image.png) 5. 在博客根目录打开cmd输入hexo g和hexo s在本地预览查看]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
